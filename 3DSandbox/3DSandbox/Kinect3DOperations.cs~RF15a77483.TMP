using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Media;
using System.Windows.Media.Media3D;

namespace _3DSandbox
{
    class Kinect3DOperations
    {
        public DepthMasterControl depthMasterControl;
        public RenderViewFunctionalities renderViewFunctionalities;
        
        public double cubeSize = 3.24;
        public List<string> vertices = new List<string>();
        public List<string> triangles = new List<string>();

        public Dictionary<string, Dictionary<int, Point3D>> verticesGrid = 
            new Dictionary<string, Dictionary<int, Point3D>>();
        public Dictionary<string, Dictionary<int, Point3D>> planeVerticesGrid = 
            new Dictionary<string, Dictionary<int, Point3D>>();
        public List<Point3D[]> planeTrianglesList = new List<Point3D[]>();


        public List<Point3D> findCubeCrossSections(double[] cubeLimit, double xCoeff, double yCoeff,
                                            double zCoeff, double constant)
        {
            List<Point3D> intersections = new List<Point3D>();
            double x, y, z;
            double[] cubeLimits = new double[6];
            cubeLimits[0] = cubeLimit[0] * cubeSize;
            cubeLimits[1] = cubeLimit[1] * cubeSize;
            cubeLimits[2] = cubeLimit[2] * cubeSize;
            cubeLimits[3] = cubeLimit[3] * cubeSize;
            cubeLimits[4] = cubeLimit[4] * cubeSize;
            cubeLimits[5] = cubeLimit[5] * cubeSize;

            // Side AB: z axis
            x = cubeLimits[0];
            y = cubeLimits[3];
            z = (constant - (x * xCoeff) - (y * yCoeff)) / zCoeff;
            if (z > cubeLimits[4] && z < cubeLimits[5])
            {
                intersections.Add(new Point3D(x, y, z));
            }

            // Side BC: x axis
            z = cubeLimits[4];
            y = cubeLimits[3];
            x = (constant - (z * zCoeff) - (y * yCoeff)) / xCoeff;
            if (x > cubeLimits[0] && x < cubeLimits[1])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side CD: z axis
            x = cubeLimits[1];
            y = cubeLimits[3];
            z = (constant - (x * xCoeff) - (y * yCoeff)) / zCoeff;
            if (z > cubeLimits[4] && z < cubeLimits[5])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side DA: x axis
            z = cubeLimits[5];
            y = cubeLimits[3];
            x = (constant - (z * zCoeff) - (y * yCoeff)) / xCoeff;
            if (x > cubeLimits[0] && x < cubeLimits[1])
            {
                intersections.Add(new Point3D(x, y, z));

            }


            // Side EF: z axis
            x = cubeLimits[0];
            y = cubeLimits[2];
            z = (constant - (x * xCoeff) - (y * yCoeff)) / zCoeff;
            if (z > cubeLimits[4] && z < cubeLimits[5])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side FG: x axis
            z = cubeLimits[4];
            y = cubeLimits[2];
            x = (constant - (z * zCoeff) - (y * yCoeff)) / xCoeff;
            if (x > cubeLimits[0] && x < cubeLimits[1])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side GH: z axis
            x = cubeLimits[1];
            y = cubeLimits[2];
            z = (constant - (x * xCoeff) - (y * yCoeff)) / zCoeff;
            if (z > cubeLimits[4] && z < cubeLimits[5])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side HE: x axis
            z = cubeLimits[5];
            y = cubeLimits[2];
            x = (constant - (z * zCoeff) - (y * yCoeff)) / xCoeff;
            if (x > cubeLimits[0] && x < cubeLimits[1])
            {
                intersections.Add(new Point3D(x, y, z));

            }


            // Side AE: y axis
            x = cubeLimits[0];
            z = cubeLimits[5];
            y = (constant - (z * zCoeff) - (x * xCoeff)) / yCoeff;
            if (y > cubeLimits[2] && y < cubeLimits[3])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side BF: y axis
            x = cubeLimits[0];
            z = cubeLimits[4];
            y = (constant - (z * zCoeff) - (x * xCoeff)) / yCoeff;
            if (y > cubeLimits[2] && y < cubeLimits[3])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side CG: y axis
            x = cubeLimits[1];
            z = cubeLimits[4];
            y = (constant - (z * zCoeff) - (x * xCoeff)) / yCoeff;
            if (y > cubeLimits[2] && y < cubeLimits[3])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side DH: y axis
            x = cubeLimits[1];
            z = cubeLimits[5];
            y = (constant - (z * zCoeff) - (x * xCoeff)) / yCoeff;
            if (y > cubeLimits[2] && y < cubeLimits[3])
            {
                intersections.Add(new Point3D(x, y, z));

            }

            return intersections;
        }

        public string[] findAllNeighborKeys(string key, int neighborhoodSize)
        {
            double X_gridLimitFloor = 0;
            double X_gridLimitCeiling = 0;
            double Y_gridLimitFloor = 0;
            double Y_gridLimitCeiling = 0;
            double Z_gridLimitFloor = 0;
            double Z_gridLimitCeiling = 0;

            double X_gridLimitFloorCurr = 0;
            double X_gridLimitCeilingCurr = 0;
            double Y_gridLimitFloorCurr = 0;
            double Y_gridLimitCeilingCurr = 0;
            double Z_gridLimitFloorCurr = 0;
            double Z_gridLimitCeilingCurr = 0;

            string[] allNeighborKeys = new string[neighborhoodSize * neighborhoodSize * neighborhoodSize - 1];

            string[] pairSeperatedKey;
            string[] rangeSeperatedKey;

            int i, j, k, strIndex = 0;
            int midpoint = neighborhoodSize / 2;

            int offsetStarting = (neighborhoodSize / 2) * -1;
            int[] offsets = new int[neighborhoodSize];
            for (i = 0; i < neighborhoodSize; i++)
            {
                offsets[i] = offsetStarting;
                offsetStarting++;
            }

            pairSeperatedKey = key.Split(',');
            rangeSeperatedKey = pairSeperatedKey[0].Split('/');
            X_gridLimitFloorCurr = Double.Parse(rangeSeperatedKey[0]);
            X_gridLimitCeilingCurr = Double.Parse(rangeSeperatedKey[1]);

            rangeSeperatedKey = pairSeperatedKey[1].Split('/');
            Y_gridLimitFloorCurr = Double.Parse(rangeSeperatedKey[0]);
            Y_gridLimitCeilingCurr = Double.Parse(rangeSeperatedKey[1]);

            rangeSeperatedKey = pairSeperatedKey[2].Split('/');
            Z_gridLimitFloorCurr = Double.Parse(rangeSeperatedKey[0]);
            Z_gridLimitCeilingCurr = Double.Parse(rangeSeperatedKey[1]);

            for (i = 0; i < neighborhoodSize; i++)
            {
                for (j = 0; j < neighborhoodSize; j++)
                {
                    for (k = 0; k < neighborhoodSize; k++)
                    {
                        if (!(i == midpoint && j == midpoint && k == midpoint))
                        {
                            X_gridLimitFloor = X_gridLimitFloorCurr + offsets[i];
                            X_gridLimitCeiling = X_gridLimitCeilingCurr + offsets[i];

                            Y_gridLimitFloor = Y_gridLimitFloorCurr + offsets[j];
                            Y_gridLimitCeiling = Y_gridLimitCeilingCurr + offsets[j];

                            Z_gridLimitFloor = Z_gridLimitFloorCurr + offsets[k];
                            Z_gridLimitCeiling = Z_gridLimitCeilingCurr + offsets[k];

                            allNeighborKeys[strIndex] = X_gridLimitFloor + "/" + X_gridLimitCeiling + "," +
                                Y_gridLimitFloor + "/" + Y_gridLimitCeiling + "," +
                                Z_gridLimitFloor + "/" + Z_gridLimitCeiling;
                            strIndex++;
                        }
                    }
                }
            }

            return allNeighborKeys;
        }

        public Kinect3DOperations(ref DepthMasterControl depthMasterControl,
                                  ref RenderViewFunctionalities renderViewFunctionalities)
        {
            this.depthMasterControl = depthMasterControl;
            this.renderViewFunctionalities = renderViewFunctionalities;
        }

        public void savePointCloud()
        {
            //depth_master_control.pointCloudArray

            string path = "D:/Solar Project/XBOX ONE/MESA 3D/3DSandbox/3DSandbox/Text Files/saved_point_cloud.txt";
            string strToWrite = "";
            int limit = depthMasterControl.pointCloudArrayDouble.Length;
            int k = 0;
            Byte[] info;
            double X = 0.0;
            double Y = 0.0;
            double Z = 0.0;
            double X_gridLimitFloor = 0.0;
            double X_gridLimitCeiling = 0.0;
            double Y_gridLimitFloor = 0.0;
            double Y_gridLimitCeiling = 0.0;
            double Z_gridLimitFloor = 0.0;
            double Z_gridLimitCeiling = 0.0;
            string[] gridLimitsStr = new string[6];
            string gridLimitsStrWholes = "";

            Dictionary<int, Point3D> containedGridVertices = new Dictionary<int, Point3D>();

            using (FileStream fs = File.Open(path, FileMode.Open, FileAccess.Write, FileShare.None))
            {
                for (int i = 0; i < limit; i = i + 3)
                {
                    if (depthMasterControl.pointCloudArray[i] != 0 && depthMasterControl.pointCloudArray[i + 1] != 0
                        && depthMasterControl.pointCloudArray[i + 2] != 0)
                    {

                        X = depthMasterControl.pointCloudArrayDouble[i + k++] / 8;
                        Y = depthMasterControl.pointCloudArrayDouble[i + k++] / 8;
                        Z = depthMasterControl.pointCloudArrayDouble[i + k++] / 8;
                        k = 0;

                        X_gridLimitFloor = Math.Floor(X);
                        Y_gridLimitFloor = Math.Floor(Y);
                        Z_gridLimitFloor = Math.Floor(Z);
                        X_gridLimitCeiling = Math.Ceiling(X);
                        Y_gridLimitCeiling = Math.Ceiling(Y);
                        Z_gridLimitCeiling = Math.Ceiling(Z);

                        gridLimitsStr = new string[6];
                        gridLimitsStr[0] = Math.Floor(X).ToString();
                        gridLimitsStr[2] = Math.Floor(Y).ToString();
                        gridLimitsStr[4] = Math.Floor(Z).ToString();
                        gridLimitsStr[1] = Math.Ceiling(X).ToString();
                        gridLimitsStr[3] = Math.Ceiling(Y).ToString();
                        gridLimitsStr[5] = Math.Ceiling(Z).ToString();

                        gridLimitsStrWholes = gridLimitsStr[0] + "/" + gridLimitsStr[1] + "," + gridLimitsStr[2]
                            + "/" + gridLimitsStr[3] + "," + gridLimitsStr[4] + "/" + gridLimitsStr[5];

                        if (verticesGrid.ContainsKey(gridLimitsStrWholes))
                        {
                            containedGridVertices = verticesGrid[gridLimitsStrWholes];
                            containedGridVertices.Add(i, new Point3D(X * 8, Y * 8, Z * 8));
                        }
                        else
                        {
                            containedGridVertices = new Dictionary<int, Point3D>();
                            containedGridVertices.Add(i, new Point3D(X * 8, Y * 8, Z * 8));
                            verticesGrid.Add(gridLimitsStrWholes, containedGridVertices);
                        }

                        strToWrite = (depthMasterControl.pointCloudArrayDouble[i + k++]) + " " +
                                     (depthMasterControl.pointCloudArrayDouble[i + k++]) + " " +
                                     (depthMasterControl.pointCloudArrayDouble[i + k++]) + "\n";
                        k = 0;
                        info = new UTF8Encoding(true).GetBytes(strToWrite);
                        fs.Write(info, 0, info.Length);
                    }
                }
            }

            int maxVerticesPerCube = 0;

            path = "D:/Solar Project/XBOX ONE/MESA 3D/3DSandbox/3DSandbox/Text Files/saved_point_cloud2.txt";
            using (FileStream fs = File.Open(path, FileMode.Open, FileAccess.Write, FileShare.None))
            {
                var keys = verticesGrid.Keys;

                foreach (string key in keys)
                {
                    containedGridVertices = verticesGrid[key];
                    var containedGridVerticesKeys = containedGridVertices.Keys;

                    int j = containedGridVerticesKeys.Count;

                    foreach (int vertex in containedGridVerticesKeys)
                    {
                        Point3D point = containedGridVertices[vertex];
                        strToWrite = "[" + key + "]";
                        strToWrite += "  :  v = " + vertex + " pos:";
                        strToWrite += point.ToString() + "\n";
                        info = new UTF8Encoding(true).GetBytes(strToWrite);
                        fs.Write(info, 0, info.Length);
                    }

                    if (j > maxVerticesPerCube)
                    {
                        maxVerticesPerCube = j;
                    }
                }

                info = new UTF8Encoding(true).GetBytes("Max: " + maxVerticesPerCube + "\n");
                fs.Write(info, 0, info.Length);

                int count = 0;
                int i = 0;
                keys = verticesGrid.Keys;

                for (i = 0; i < maxVerticesPerCube; i++)
                {
                    count = 0;
                    foreach (string key in keys)
                    {
                        containedGridVertices = verticesGrid[key];
                        var containedGridVerticesKeys = containedGridVertices.Keys;
                        if ((i + 1) == containedGridVerticesKeys.Count)
                        {
                            count++;
                        }
                    }

                    info = new UTF8Encoding(true).GetBytes("Number of Verticees: " + (i + 1) + " : " + count + "\n");
                    fs.Write(info, 0, info.Length);
                }

                int numOfLoneVerticees = verticesGrid.Keys.Count;
                int numOfLoneCubes = verticesGrid.Keys.Count;

                string[] neighborStr;

                /*
                foreach (string key in keys)
                {
                    containedGridVertices = verticesGrid[key];
                    var containedGridVerticesKeys = containedGridVertices.Keys;
                    if (containedGridVerticesKeys.Count == 1)
                    {
                        neighborStr = findAllNeighborKeys(key, 3);
                        foreach(string singleNeighbor in neighborStr)
                        {
                            if(verticesGrid.ContainsKey(singleNeighbor))
                            {
                                numOfLoneVerticees--;
                                break;
                            }
                        }
                    }
                    
                    if (containedGridVerticesKeys.Count > 0)
                    {
                        neighborStr = findAllNeighborKeys(key, 7);
                        foreach (string singleNeighbor in neighborStr)
                        {
                            if (verticesGrid.ContainsKey(singleNeighbor))
                            {
                                numOfLoneCubes--;
                                break;
                            }
                        }
                    }
                }
                */

                info = new UTF8Encoding(true).GetBytes("Number of Lone Vertices" + " : " + numOfLoneVerticees + "\n");
                fs.Write(info, 0, info.Length);
                info = new UTF8Encoding(true).GetBytes("Number of Lone Cubes" + " : " + numOfLoneCubes + "\n");
                fs.Write(info, 0, info.Length);

            }
        }

        public void renderTrianglePlanes()
        {
            MeshGeometry3D pointCloudMesh = new MeshGeometry3D();
            DiffuseMaterial surface_material = new DiffuseMaterial(Brushes.Violet);

            foreach (Point3D[] triangle in planeTrianglesList)
            {
                renderViewFunctionalities.AddTriangle(pointCloudMesh, triangle[0], triangle[1], triangle[2]);
            }

            GeometryModel3D surface_model_cuboid = new GeometryModel3D(pointCloudMesh, surface_material);

            // Make the surface visible from both sides.
            surface_model_cuboid.BackMaterial = surface_material;

            // Add the model to the model groups.
            renderViewFunctionalities.MainModel3Dgroup.Children.Add(surface_model_cuboid);
        }

        public void renderTriangles()
        {
            verticesGrid = this.verticesGrid;
            Dictionary<int, Point3D> containedGridVertices = new Dictionary<int, Point3D>();
            var keys = verticesGrid.Keys;
            Point3D vertexPoint;
            Point3D[] threeVertexPoint = new Point3D[3];
            int i = 0;
            Vector3D firstVector, secondVector, normalVector;

            MeshGeometry3D pointCloudMesh = new MeshGeometry3D();
            DiffuseMaterial surface_material = new DiffuseMaterial(Brushes.Violet);

            foreach (string key in keys)
            {
                containedGridVertices = verticesGrid[key];
                var containedGridVerticesKeys = containedGridVertices.Keys;

                if (containedGridVerticesKeys.Count >= 3)
                {
                    if (containedGridVerticesKeys.Count == 3)
                    {
                        foreach (int vertex in containedGridVerticesKeys)
                        {
                            if (i < 3)
                            {
                                threeVertexPoint[i] = containedGridVertices[vertex];
                            }
                            i++;
                        }
                        i = 0;

                        firstVector = threeVertexPoint[1] - threeVertexPoint[0];
                        secondVector = threeVertexPoint[2] - threeVertexPoint[0];

                        normalVector = new Vector3D();
                        normalVector = Vector3D.CrossProduct(firstVector, secondVector);

                        Point3D point1 = new Point3D(threeVertexPoint[0].X / 1, threeVertexPoint[0].Y / 1,
                            threeVertexPoint[0].Z / 1);
                        Point3D point2 = new Point3D(threeVertexPoint[1].X / 1, threeVertexPoint[1].Y / 1,
                            threeVertexPoint[1].Z / 1);
                        Point3D point3 = new Point3D(threeVertexPoint[2].X / 1, threeVertexPoint[2].Y / 1,
                            threeVertexPoint[2].Z / 1);

                        renderViewFunctionalities.AddTriangle(pointCloudMesh, point1, point2, point3);
                    }
                    else
                    {
                        foreach (int vertex in containedGridVerticesKeys)
                        {
                            vertexPoint = containedGridVertices[vertex];
                        }
                    }
                }
                else
                {
                    foreach (int vertex in containedGridVerticesKeys)
                    {
                        Point3D point1 = new Point3D(containedGridVertices[vertex].X / 1 + 2,
                            containedGridVertices[vertex].Y / 1,
                            containedGridVertices[vertex].Z / 1);
                        renderViewFunctionalities.renderSingleVertex(pointCloudMesh, point1);
                    }
                }
            }

            GeometryModel3D surface_model_cuboid = new GeometryModel3D(pointCloudMesh, surface_material);

            // Make the surface visible from both sides.
            surface_model_cuboid.BackMaterial = surface_material;

            // Add the model to the model groups.
            renderViewFunctionalities.MainModel3Dgroup.Children.Add(surface_model_cuboid);
        }



        public void pointCloudOfExample()
        {
            //depth_master_control.pointCloudArray

            string path = "D:/Solar Project/XBOX ONE/MESA 3D/3DSandbox/3DSandbox/Text Files/saved_point_cloud.txt";
            string strToWrite = "";
            int limit = vertices.Count;
            int k = 0;
            Byte[] info;
            double X = 0.0;
            double Y = 0.0;
            double Z = 0.0;
            double X_gridLimitFloor = 0.0;
            double X_gridLimitCeiling = 0.0;
            double Y_gridLimitFloor = 0.0;
            double Y_gridLimitCeiling = 0.0;
            double Z_gridLimitFloor = 0.0;
            double Z_gridLimitCeiling = 0.0;
            string[] gridLimitsStr = new string[6];
            string gridLimitsStrWholes = "";
            string[] vertexStrArr;

            int i = 0;

            Dictionary<int, Point3D> containedGridVertices = new Dictionary<int, Point3D>();

            foreach (string vertexStr in vertices)
            {
                vertexStrArr = vertexStr.Split(' ');

                X = Double.Parse(vertexStrArr[0]) / cubeSize;
                Y = Double.Parse(vertexStrArr[1]) / cubeSize;
                Z = Double.Parse(vertexStrArr[2]) / cubeSize;

                gridLimitsStr = new string[6];
                gridLimitsStr[0] = Math.Floor(X).ToString();
                gridLimitsStr[2] = Math.Floor(Y).ToString();
                gridLimitsStr[4] = Math.Floor(Z).ToString();
                gridLimitsStr[1] = Math.Ceiling(X).ToString();
                gridLimitsStr[3] = Math.Ceiling(Y).ToString();
                gridLimitsStr[5] = Math.Ceiling(Z).ToString();

                gridLimitsStrWholes = gridLimitsStr[0] + "/" + gridLimitsStr[1] + "," + gridLimitsStr[2]
                        + "/" + gridLimitsStr[3] + "," + gridLimitsStr[4] + "/" + gridLimitsStr[5];

                if (verticesGrid.ContainsKey(gridLimitsStrWholes))
                {
                    containedGridVertices = verticesGrid[gridLimitsStrWholes];
                    containedGridVertices.Add(i, new Point3D(X * cubeSize, Y * cubeSize, Z * cubeSize));
                }
                else
                {
                    containedGridVertices = new Dictionary<int, Point3D>();
                    containedGridVertices.Add(i, new Point3D(X * cubeSize, Y * cubeSize, Z * cubeSize));
                    verticesGrid.Add(gridLimitsStrWholes, containedGridVertices);
                }
                i++;
            }

            int maxVerticesPerCube = 0;

            path = "D:/Solar Project/XBOX ONE/MESA 3D/3DSandbox/3DSandbox/Text Files/saved_point_cloud2.txt";
            using (FileStream fs = File.Open(path, FileMode.Open, FileAccess.Write, FileShare.None))
            {
                var keys = verticesGrid.Keys;

                foreach (string key in keys)
                {
                    containedGridVertices = verticesGrid[key];
                    var containedGridVerticesKeys = containedGridVertices.Keys;

                    int j = containedGridVerticesKeys.Count;

                    foreach (int vertex in containedGridVerticesKeys)
                    {
                        Point3D point = containedGridVertices[vertex];
                        strToWrite = "[" + key + "]";
                        strToWrite += "  :  v = " + vertex + " pos:";
                        strToWrite += point.ToString() + "\n";
                        info = new UTF8Encoding(true).GetBytes(strToWrite);
                        fs.Write(info, 0, info.Length);
                    }

                    if (j > maxVerticesPerCube)
                    {
                        maxVerticesPerCube = j;
                    }
                }

                info = new UTF8Encoding(true).GetBytes("Max: " + maxVerticesPerCube + "\n");
                fs.Write(info, 0, info.Length);

                int count = 0;
                i = 0;
                keys = verticesGrid.Keys;

                for (i = 0; i < maxVerticesPerCube; i++)
                {
                    count = 0;
                    foreach (string key in keys)
                    {
                        containedGridVertices = verticesGrid[key];
                        var containedGridVerticesKeys = containedGridVertices.Keys;
                        if ((i + 1) == containedGridVerticesKeys.Count)
                        {
                            count++;
                        }
                    }

                    info = new UTF8Encoding(true).GetBytes("Number of Verticees: " + (i + 1) + " : " + count + "\n");
                    fs.Write(info, 0, info.Length);
                }

                int numOfLoneVerticees = verticesGrid.Keys.Count;
                int numOfLoneCubes = verticesGrid.Keys.Count;

                string[] neighborStr;


                foreach (string key in keys)
                {
                    containedGridVertices = verticesGrid[key];
                    var containedGridVerticesKeys = containedGridVertices.Keys;
                    if (containedGridVerticesKeys.Count == 1)
                    {
                        neighborStr = findAllNeighborKeys(key, 3);
                        foreach (string singleNeighbor in neighborStr)
                        {
                            if (verticesGrid.ContainsKey(singleNeighbor))
                            {
                                numOfLoneVerticees--;
                                break;
                            }
                        }
                    }

                    if (containedGridVerticesKeys.Count > 0)
                    {
                        neighborStr = findAllNeighborKeys(key, 7);
                        foreach (string singleNeighbor in neighborStr)
                        {
                            if (verticesGrid.ContainsKey(singleNeighbor))
                            {
                                numOfLoneCubes--;
                                break;
                            }
                        }
                    }
                }


                info = new UTF8Encoding(true).GetBytes("Number of Lone Vertices" + " : " + numOfLoneVerticees + "\n");
                fs.Write(info, 0, info.Length);
                info = new UTF8Encoding(true).GetBytes("Number of Lone Cubes" + " : " + numOfLoneCubes + "\n");
                fs.Write(info, 0, info.Length);

            }
        }


        /// <summary>
        /// Create a mesh that is simplified from the vectex grid that we have populated
        /// before. Planes are created at each grid, which are estimated based on the different
        /// vertices present. These planes are then connected to create a mesh.
        /// </summary>
        public void createSimplifiedMeshFromGrid()
        {
            Dictionary<int, Point3D> containedGridVertices = new Dictionary<int, Point3D>();
            Dictionary<int, Point3D> containedGridVerticesPlane;
            var keys = verticesGrid.Keys;
            int i = 0;
            Point3D[] trianglePoints = new Point3D[3];
            int planeVerticesIndex = 0;
            Vector3D vector1, vector2, normalVector;
            double xCoeff, yCoeff, zCoeff, contstantOfPlaneEq;
            double[] cubeLimits = new double[6];
            int numberOfIntersections = 0;
            string[] pairSeperatedKey;
            string[] rangeSeperatedKey;

            foreach (string key in keys)
            {
                pairSeperatedKey = key.Split(',');
                rangeSeperatedKey = pairSeperatedKey[0].Split('/');
                cubeLimits[0] = Double.Parse(rangeSeperatedKey[0]);
                cubeLimits[1] = Double.Parse(rangeSeperatedKey[1]);

                rangeSeperatedKey = pairSeperatedKey[1].Split('/');
                cubeLimits[2] = Double.Parse(rangeSeperatedKey[0]);
                cubeLimits[3] = Double.Parse(rangeSeperatedKey[1]);

                rangeSeperatedKey = pairSeperatedKey[2].Split('/');
                cubeLimits[4] = Double.Parse(rangeSeperatedKey[0]);
                cubeLimits[5] = Double.Parse(rangeSeperatedKey[1]);


                containedGridVertices = verticesGrid[key];
                var containedGridVerticesKeys = containedGridVertices.Keys;

                containedGridVerticesPlane = new Dictionary<int, Point3D>();

                trianglePoints = new Point3D[3];
                i = 0;
                int closestIndex = 0;

                foreach (int vertex in containedGridVerticesKeys)
                {
                    Point3D point = containedGridVertices[vertex];

                    if (i > 2)
                    {
                        closestIndex = findClosestTriangleVertex(trianglePoints, point);
                        trianglePoints[closestIndex] = mergeTwoPoints(trianglePoints[closestIndex], point);
                    }
                    else
                    {
                        trianglePoints[i] = point;
                        i++;
                    }

                }


                if (i > 2)
                {
                    // Find normal Vector of Triangle:
                    vector1 = new Vector3D(trianglePoints[1].X - trianglePoints[0].X,
                        trianglePoints[1].Y - trianglePoints[0].Y,
                        trianglePoints[1].Z - trianglePoints[0].Z);

                    vector2 = new Vector3D(trianglePoints[2].X - trianglePoints[0].X,
                        trianglePoints[2].Y - trianglePoints[0].Y,
                        trianglePoints[2].Z - trianglePoints[0].Z);

                    normalVector = Vector3D.CrossProduct(vector1, vector2);

                    // Lets get equation of plane:
                    contstantOfPlaneEq = trianglePoints[0].X * normalVector.X + trianglePoints[0].Y * normalVector.Y
                        + trianglePoints[0].Z * normalVector.Z;

                    // Lets get the intersections of this plane with the grid:
                    List<Point3D> intersections = findCubeCrossSections(cubeLimits, normalVector.X, normalVector.Y,
                        normalVector.Z, contstantOfPlaneEq);

                    createPlaneTriangles(intersections, intersections.Count);
                }


                for (int j = 0; j < i; j++)
                {
                    containedGridVerticesPlane.Add(planeVerticesIndex++, trianglePoints[j]);
                }

                planeVerticesGrid.Add(key, containedGridVerticesPlane);
            }
        }

        /// <summary>
        /// Create triangles based on the number of vertices of the Polygon.
        /// </summary>
        /// <param name="pointsOfPolygon"></param>
        public void convertPolygonIntoTriangles(Point3D[] pointsOfPolygon, int numberOfVertices)
        {
            Point3D[] closestNeighbors = new Point3D[numberOfVertices * 2];
            int[] closestNeighborsIndexArr = new int[numberOfVertices * 2];
            Point3D[] points = new Point3D[numberOfVertices];
            points = pointsOfPolygon.ToArray<Point3D>();

            int i = 0, closestNeighborsIndex = 0, j = 0;
            Point3D pointToHandle;
            double distance = 0, dx, dy, dz, minDistance, secondMinDistance;
            int firstMinIndex = 0, secondMinIndex = 0;
            Point3D pointToCompare;
            Point3D pointToAdd;
            HashSet<Point3D> setOfOrderedPoints = new HashSet<Point3D>();
            List<Point3D> listOfOrderedPoints = new List<Point3D>();

            for (i = 0; i < numberOfVertices; i++)
            {
                distance = 0;
                minDistance = 100;
                secondMinDistance = 100;
                firstMinIndex = 0;
                secondMinIndex = 0;
                pointToHandle = pointsOfPolygon[i];

                for(j = 0; j < numberOfVertices; j++)
                {
                    if (pointToHandle != pointsOfPolygon[j])
                    {
                        pointToCompare = pointsOfPolygon[j];
                        dx = pointToCompare.X - pointToHandle.X;
                        dy = pointToCompare.Y - pointToHandle.Y;
                        dz = pointToCompare.Z - pointToHandle.Z;
                        distance = Math.Sqrt((dx * dx) + (dy * dy) + (dz * dz));

                        if (distance < minDistance)
                        {
                            secondMinDistance = minDistance;
                            minDistance = distance;

                            secondMinIndex = firstMinIndex;
                            firstMinIndex = j;
                        }
                        else
                        {
                            if (distance < secondMinDistance)
                            {
                                secondMinDistance = distance;
                                secondMinIndex = j;
                            }
                        }
                    }
                }

                closestNeighbors[closestNeighborsIndex] = pointsOfPolygon[firstMinIndex];
                closestNeighborsIndexArr[closestNeighborsIndex++] = firstMinIndex;
                closestNeighbors[closestNeighborsIndex] = pointsOfPolygon[secondMinIndex];
                closestNeighborsIndexArr[closestNeighborsIndex++] = secondMinIndex;

            }


            i = 0;
            pointToHandle = pointsOfPolygon[0];
            listOfOrderedPoints.Add(pointToHandle);
            while (listOfOrderedPoints.Count != numberOfVertices)
            {
                pointToAdd = pointsOfPolygon[closestNeighborsIndexArr[i]];
                if(!listOfOrderedPoints.Contains(pointToAdd))
                {
                    listOfOrderedPoints.Add(pointToAdd);
                    
                } else
                {
                    pointToAdd = pointsOfPolygon[closestNeighborsIndexArr[++i]];
                    if (!listOfOrderedPoints.Contains(pointToAdd))
                    {
                        listOfOrderedPoints.Add(pointToAdd);
                    }
                }
                
                i = closestNeighborsIndexArr[i] * 2;
            }
            

        }

        public void createPlaneTriangles(List<Point3D> intersections, int numberOfIntersections)
        {
            Point3D[] trianglePoints;

            if (numberOfIntersections == 0)
            {
                trianglePoints = new Point3D[3];
                trianglePoints[0] = new Point3D(10, 10, 10);
                trianglePoints[1] = new Point3D(1, 10, 10);
                trianglePoints[2] = new Point3D(10, 1, 10);

                planeTrianglesList.Add(trianglePoints);
            }

            if (numberOfIntersections == 3)
            {
                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[1];
                trianglePoints[2] = intersections[2];

                planeTrianglesList.Add(trianglePoints);
            }
            else if (numberOfIntersections == 4)
            {
                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[1];
                trianglePoints[2] = intersections[2];

                planeTrianglesList.Add(trianglePoints);

                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[2];
                trianglePoints[2] = intersections[3];

                planeTrianglesList.Add(trianglePoints);
            }
            else if (numberOfIntersections == 5)
            {
                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[1];
                trianglePoints[2] = intersections[2];

                planeTrianglesList.Add(trianglePoints);

                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[2];
                trianglePoints[2] = intersections[3];

                planeTrianglesList.Add(trianglePoints);

                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[3];
                trianglePoints[2] = intersections[4];

                planeTrianglesList.Add(trianglePoints);
            }
            else if (numberOfIntersections == 6)
            {
                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[1];
                trianglePoints[2] = intersections[2];

                planeTrianglesList.Add(trianglePoints);

                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[2];
                trianglePoints[2] = intersections[3];

                planeTrianglesList.Add(trianglePoints);

                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[3];
                trianglePoints[2] = intersections[4];

                planeTrianglesList.Add(trianglePoints);

                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[4];
                trianglePoints[2] = intersections[5];

                planeTrianglesList.Add(trianglePoints);
            }
        }

        private int findClosestTriangleVertex(Point3D[] pointArr, Point3D point)
        {
            double distance1, distance2, distance3;
            double X, Y, Z;

            X = point.X - pointArr[0].X;
            Y = point.Y - pointArr[0].Y;
            Z = point.Z - pointArr[0].Z;

            distance1 = Math.Sqrt(X * X + Y * Y + Z * Z);

            X = point.X - pointArr[1].X;
            Y = point.Y - pointArr[1].Y;
            Z = point.Z - pointArr[1].Z;

            distance2 = Math.Sqrt(X * X + Y * Y + Z * Z);

            X = point.X - pointArr[2].X;
            Y = point.Y - pointArr[2].Y;
            Z = point.Z - pointArr[2].Z;

            distance3 = Math.Sqrt(X * X + Y * Y + Z * Z);

            if (distance1 < distance2 && distance1 < distance3)
            {
                return 0;
            }
            else
            {
                if (distance2 < distance3)
                {
                    return 1;
                }
                else
                {
                    return 2;
                }
            }
        }

        private Point3D mergeTwoPoints(Point3D point1, Point3D point2)
        {
            Point3D mergedPoint = new Point3D();
            double X, Y, Z;

            X = (point1.X - point2.X) / 2;
            Y = (point1.Y - point2.Y) / 2;
            Z = (point1.Z - point2.Z) / 2;

            mergedPoint = new Point3D(point2.X + X, point2.Y + Y, point2.Z + Z);

            return mergedPoint;
        }

        /// <summary>
        /// Extract vertices and triangles from their designated files.
        /// </summary>
        /// <param name="triangles"></param>
        /// <param name="vertices"></param>
        public void extractMeshDataFromFiles()
        {
            //string path = "D:/Solar Project/triangle_scope.txt";
            //string path = "D:/Solar Project/XBOX ONE/MESA 3D/Extras/teapotTriangles.txt";
            string path = "D:/Solar Project/XBOX ONE/MESA 3D/Extras/hTsphereTriangles.txt";
            string line;

            System.IO.StreamReader file =
            new System.IO.StreamReader(path);
            while ((line = file.ReadLine()) != null)
            {
                triangles.Add(line);
            }

            file.Close();

            //path = "D:/Solar Project/vertex_scope.txt";
            //path = "D:/Solar Project/XBOX ONE/MESA 3D/Extras/teapotVertices.txt";
            path = "D:/Solar Project/XBOX ONE/MESA 3D/Extras/hTsphereVertices.txt";
            System.IO.StreamReader file2 =
            new System.IO.StreamReader(path);
            while ((line = file2.ReadLine()) != null)
            {
                vertices.Add(line);
            }

            file2.Close();
        }

    }
}
