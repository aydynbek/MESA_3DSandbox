namespace _3DSandbox
{
    using Accord.Controls;
    using Accord.Imaging;
    using Accord;
    using Microsoft.Kinect;
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Text;
    using System.Windows;
    using System.Windows.Input;
    using System.Windows.Media;
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Windows;
    using System.Windows.Media;
    using Microsoft.Kinect;
    using System.Windows.Media.Imaging;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window, INotifyPropertyChanged
    {
        private double cubeSize = 1;

        public MainWindow()
        {
            // one sensor is currently supported
            this.kinectSensor = KinectSensor.GetDefault();

            // open the reader for the color frames
            this.colorFrameReader = this.kinectSensor.ColorFrameSource.OpenReader();

            // create the colorFrameDescription from the ColorFrameSource using Bgra format
            FrameDescription colorFrameDescription = this.kinectSensor.ColorFrameSource.CreateFrameDescription(ColorImageFormat.Bgra);

            // Instantiate the Color Processing:
            color_master_control = new ColorMasterConrol(colorFrameDescription.Width, colorFrameDescription.Height);

            // Create the drawing group we'll use for drawing
            this.drawingGroupColorHUD = new DrawingGroup();

            // Create an image source that we can use as the HUD
            this.imageSourceColorHUD = new DrawingImage(this.drawingGroupColorHUD);

            // get the coordinate mapper
            this.coordinateMapper = this.kinectSensor.CoordinateMapper;

            // open the reader for the depth frames
            this.depthFrameReader = this.kinectSensor.DepthFrameSource.OpenReader();


            // get FrameDescription from DepthFrameSource
            this.depthFrameDescription = this.kinectSensor.DepthFrameSource.FrameDescription;

            // allocate space to put the pixels being received and converted
            this.depthPixels = new byte[this.depthFrameDescription.Width * this.depthFrameDescription.Height];

            // create the bitmap to display
            this.depthBitmap = new WriteableBitmap(this.depthFrameDescription.Width, this.depthFrameDescription.Height, 96.0, 96.0, PixelFormats.Gray8, null);

            // create the bitmap to display color depth
            this.depthBitmapColor = new WriteableBitmap(this.depthFrameDescription.Width, this.depthFrameDescription.Height, 96.0, 96.0, PixelFormats.Bgra32, null);

            // get the depth (display) extents
            FrameDescription frameDescription = this.kinectSensor.DepthFrameSource.FrameDescription;

            // get size of joint space
            this.displayWidth = frameDescription.Width;
            this.displayHeight = frameDescription.Height;



            // open the reader for the body frames
            this.bodyFrameReader = this.kinectSensor.BodyFrameSource.OpenReader();

            // a bone defined as a line between two joints
            this.bones = new List<Tuple<JointType, JointType>>();

            // Torso
            this.bones.Add(new Tuple<JointType, JointType>(JointType.Head, JointType.Neck));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.Neck, JointType.SpineShoulder));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.SpineShoulder, JointType.SpineMid));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.SpineMid, JointType.SpineBase));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.SpineShoulder, JointType.ShoulderRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.SpineShoulder, JointType.ShoulderLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.SpineBase, JointType.HipRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.SpineBase, JointType.HipLeft));

            // Right Arm
            this.bones.Add(new Tuple<JointType, JointType>(JointType.ShoulderRight, JointType.ElbowRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.ElbowRight, JointType.WristRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.WristRight, JointType.HandRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.HandRight, JointType.HandTipRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.WristRight, JointType.ThumbRight));

            // Left Arm
            this.bones.Add(new Tuple<JointType, JointType>(JointType.ShoulderLeft, JointType.ElbowLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.ElbowLeft, JointType.WristLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.WristLeft, JointType.HandLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.HandLeft, JointType.HandTipLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.WristLeft, JointType.ThumbLeft));

            // Right Leg
            this.bones.Add(new Tuple<JointType, JointType>(JointType.HipRight, JointType.KneeRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.KneeRight, JointType.AnkleRight));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.AnkleRight, JointType.FootRight));

            // Left Leg
            this.bones.Add(new Tuple<JointType, JointType>(JointType.HipLeft, JointType.KneeLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.KneeLeft, JointType.AnkleLeft));
            this.bones.Add(new Tuple<JointType, JointType>(JointType.AnkleLeft, JointType.FootLeft));

            // populate body colors, one for each BodyIndex
            this.bodyColors = new List<Pen>();

            this.bodyColors.Add(new Pen(Brushes.Red, 6));
            this.bodyColors.Add(new Pen(Brushes.Orange, 6));
            this.bodyColors.Add(new Pen(Brushes.Green, 6));
            this.bodyColors.Add(new Pen(Brushes.Blue, 6));
            this.bodyColors.Add(new Pen(Brushes.Indigo, 6));
            this.bodyColors.Add(new Pen(Brushes.Violet, 6));

            // set IsAvailableChanged event notifier
            this.kinectSensor.IsAvailableChanged += this.Sensor_IsAvailableChanged;

            // open the sensor
            this.kinectSensor.Open();

            // set the status text
            this.StatusText = this.kinectSensor.IsAvailable ? Properties.Resources.RunningStatusText
                                                            : Properties.Resources.NoSensorStatusText;

            // Create the drawing group we'll use for drawing
            this.drawingGroup = new DrawingGroup();

            this.drawingGroupDepth = new DrawingGroup();

            // Create an image source that we can use in our image control
            this.imageSource = new DrawingImage(this.drawingGroup);

            // Create an image source for depth
            this.imageSourceDepth = new DrawingImage(this.drawingGroupDepth);
            // use the window object as the view model in this simple example
            this.DataContext = this;

            InitializeComponent();
        }

        /// <summary>
        /// INotifyPropertyChangedPropertyChanged event to allow window controls to bind to changeable data
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;

        /// <summary>
        /// Gets the bitmap to display
        /// </summary>
        public ImageSource ImageSource
        {
            get
            {
                return this.imageSource;
            }
        }
        /*
        /// <summary>
        /// Gets the bitmap to display for COLOR HUD
        /// </summary>
        public ImageSource ImageSourceColorHUD
        {
            get
            {
                return this.imageSourceColorHUD;
            }
        }
        
        /// <summary>
        /// Gets the bitmap to display
        /// </summary>
        public ImageSource ImageSourceDepth
        {
            get
            {
                //return this.depthBitmap;
                //return this.depthBitmapColor;
                //return depth_master_control.ToBitmap();
                return depth_master_control.ToBitmap();
            }
        }
        */
        /// <summary>
        /// Gets or sets the current status text to display
        /// </summary>
        public string StatusText
        {
            get
            {
                return this.statusText;
            }

            set
            {
                if (this.statusText != value)
                {
                    this.statusText = value;

                    // notify any bound elements that the text has changed
                    if (this.PropertyChanged != null)
                    {
                        this.PropertyChanged(this, new PropertyChangedEventArgs("StatusText"));
                    }
                }
            }
        }

        /* Color Related Variables */
        /// <summary>
        /// Reader for color frames
        /// </summary>
        private ColorFrameReader colorFrameReader = null;

        /// <summary>
        /// Drawing image that we will display
        /// </summary>
        private DrawingImage imageSourceColorHUD;

        /// <summary>
        /// Drawing group HUD
        /// </summary>
        private DrawingGroup drawingGroupColorHUD;

        private bool colorFirst = false;

        /* Depth Related Variables */
        private int depthFrameCounter = 0;

        /// <summary>
        /// Reader for depth frames
        /// </summary>
        private DepthFrameReader depthFrameReader = null;

        /// <summary>
        /// Map depth range to byte range
        /// </summary>
        private const int MapDepthToByte = 8000 / 256;

        /// <summary>
        /// Description of the data contained in the depth frame
        /// </summary>
        private FrameDescription depthFrameDescription = null;

        /// <summary>
        /// Bitmap to display
        /// </summary>
        private WriteableBitmap depthBitmap = null;

        /// <summary>
        /// Bitmap to display color depth
        /// </summary>
        private WriteableBitmap depthBitmapColor = null;

        /// <summary>
        /// Intermediate storage for frame data converted to color
        /// </summary>
        private byte[] depthPixels = null;

        /// <summary>
        /// Depth Image
        /// </summary>
        private DrawingImage imageSourceDepth;

        /// <summary>
        /// Radius of drawn hand circles
        /// </summary>
        private const double HandSize = 30;

        /// <summary>
        /// Thickness of drawn joint lines
        /// </summary>
        private const double JointThickness = 3;

        /// <summary>
        /// Thickness of clip edge rectangles
        /// </summary>
        private const double ClipBoundsThickness = 10;

        /// <summary>
        /// Constant for clamping Z values of camera space points from being negative
        /// </summary>
        private const float InferredZPositionClamp = 0.1f;

        private DrawingGroup drawingGroupDepth;

        /* Body Related Variables */
        /// <summary>
        /// Brush used for drawing hands that are currently tracked as closed
        /// </summary>
        private readonly Brush handClosedBrush = new SolidColorBrush(Color.FromArgb(128, 255, 0, 0));

        /// <summary>
        /// Brush used for drawing hands that are currently tracked as opened
        /// </summary>
        private readonly Brush handOpenBrush = new SolidColorBrush(Color.FromArgb(128, 0, 255, 0));

        /// <summary>
        /// Brush used for drawing hands that are currently tracked as in lasso (pointer) position
        /// </summary>
        private readonly Brush handLassoBrush = new SolidColorBrush(Color.FromArgb(128, 0, 0, 255));

        /// <summary>
        /// Brush used for drawing joints that are currently tracked
        /// </summary>
        private readonly Brush trackedJointBrush = new SolidColorBrush(Color.FromArgb(255, 68, 192, 68));

        /// <summary>
        /// Brush used for drawing joints that are currently inferred
        /// </summary>        
        private readonly Brush inferredJointBrush = Brushes.Yellow;

        /// <summary>
        /// Pen used for drawing bones that are currently inferred
        /// </summary>        
        private readonly Pen inferredBonePen = new Pen(Brushes.Gray, 1);

        /// <summary>
        /// Drawing group for body rendering output
        /// </summary>
        private DrawingGroup drawingGroup;

        /// <summary>
        /// Drawing image that we will display
        /// </summary>
        private DrawingImage imageSource;

        /// <summary>
        /// Active Kinect sensor
        /// </summary>
        private KinectSensor kinectSensor = null;

        /// <summary>
        /// Coordinate mapper to map one type of point to another
        /// </summary>
        private CoordinateMapper coordinateMapper = null;

        /// <summary>
        /// Reader for body frames
        /// </summary>
        private BodyFrameReader bodyFrameReader = null;

        /// <summary>
        /// Array for the bodies
        /// </summary>
        private Body[] bodies = null;

        /// <summary>
        /// definition of bones
        /// </summary>
        private List<Tuple<JointType, JointType>> bones;

        /// <summary>
        /// Width of display (depth space)
        /// </summary>
        private int displayWidth;

        /// <summary>
        /// Height of display (depth space)
        /// </summary>
        private int displayHeight;

        /// <summary>
        /// List of colors for each body tracked
        /// </summary>
        private List<Pen> bodyColors;

        /// <summary>
        /// Current status text to display
        /// </summary>
        private string statusText = null;

        /* Extras */
        private readonly Brush headGestureBrush = new SolidColorBrush(Color.FromArgb(100, 0, 255, 0));
        private const double headGestureSize = 17;

        public GesturesMasterControl gesture_master_control;
        public ColorMasterConrol color_master_control;
        public DepthMasterControl depth_master_control;

        public Queue<Body> body_queue = new Queue<Body>();
        public bool gesture_MC_loaded = false;


        // The main object model group.
        private Model3DGroup MainModel3Dgroup = new Model3DGroup();

        private bool cameraNeedsPositionUpdate = false;

        // The camera.
        private PerspectiveCamera TheCamera;

        // The camera's current location.
        private double CameraPhi = Math.PI / 4.0;       // 45 degrees
        private double CameraTheta = Math.PI / 2.0;     // 90 degrees
        private double CameraR = 30;

        private Vector3D cameraVerticalAxis = new Vector3D(0,1,0);
        private Vector3D cameraHorizontalAxis = new Vector3D(1,0,0);

        // The change in CameraPhi when you press the up and down arrows.
        private const double CameraDPhi = 0.1;

        // The change in CameraTheta when you press the left and right arrows.
        private const double CameraDTheta = 0.1;

        // The change in CameraR when you press + or -.
        private const double CameraDR = 0.3;

        private List<string> vertices = new List<string>();
        private List<string> triangles = new List<string>();

        private Dictionary<string, Dictionary<int, Point3D>> verticesGrid = new Dictionary<string, Dictionary<int, Point3D>>();
        private Dictionary<string, Dictionary<int, Point3D>> planeVerticesGrid = new Dictionary<string, Dictionary<int, Point3D>>();
        private List<Point3D[]> planeTrianglesList = new List<Point3D[]>();

        // Create the scene.
        // MainViewport is the Viewport3D defined
        // in the XAML code that displays everything.
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            // Give the camera its initial position.
            TheCamera = new PerspectiveCamera();
            TheCamera.FieldOfView = 90;
            MainViewport.Camera = TheCamera;
            PositionCamera(0,0,0);

            extractData();

            // Define lights.
            DefineLights();

            // Create the model.
           // DefineModelScope(MainModel3Dgroup);

            // Add the group of models to a ModelVisual3D.
            ModelVisual3D model_visual = new ModelVisual3D();
            model_visual.Content = MainModel3Dgroup;

            // Add the main visual to the viewportt.
            MainViewport.Children.Add(model_visual);

            if (this.bodyFrameReader != null)
            {
                this.bodyFrameReader.FrameArrived += this.Reader_FrameArrived;
            }

            if (this.depthFrameReader != null)
            {
                this.depthFrameReader.FrameArrived += this.Reader_FrameArrived_Depth;
            }

            // wire handler for frame arrival
            this.colorFrameReader.FrameArrived += this.Reader_ColorFrameArrived;
        }

        /// <summary>
        /// Handles the color frame data arriving from the sensor
        /// </summary>
        /// <param name="sender">object sending the event</param>
        /// <param name="e">event arguments</param>
        private void Reader_ColorFrameArrived(object sender, ColorFrameArrivedEventArgs e)
        {

        }

        private void drawColorHUD()
        {
            using (DrawingContext drawingContext = this.drawingGroupColorHUD.Open())
            {
                CameraSpacePoint position = new CameraSpacePoint();
                position.X = -950;
                position.Y = 0;
                position.Z = 0;

                DepthSpacePoint depthSpacePoint = this.coordinateMapper.MapCameraPointToDepthSpace(position);
                System.Windows.Point x1 = new System.Windows.Point(depthSpacePoint.X, depthSpacePoint.Y);

                position.X = 950;
                position.Y = 0;
                position.Z = 0;

                depthSpacePoint = this.coordinateMapper.MapCameraPointToDepthSpace(position);
                System.Windows.Point x2 = new System.Windows.Point(depthSpacePoint.X, depthSpacePoint.Y);

                Color colore = new Color();
                colore.ScA = 150;
                colore.ScR = 150;
                colore.ScG = 150;
                colore.ScB = 150;

                SolidColorBrush brushe = new SolidColorBrush(colore);

                Pen drawPen = new Pen(brushe, 10);

                drawingContext.DrawLine(drawPen, x1, x2);
            }
        }

        /// <summary>
        /// Execute shutdown tasks
        /// </summary>
        /// <param name="sender">object sending the event</param>
        /// <param name="e">event arguments</param>
        private void MainWindow_Closing(object sender, CancelEventArgs e)
        {
            if (this.bodyFrameReader != null)
            {
                // BodyFrameReader is IDisposable
                this.bodyFrameReader.Dispose();
                this.bodyFrameReader = null;
            }

            if (this.kinectSensor != null)
            {
                this.kinectSensor.Close();
                this.kinectSensor = null;
            }
        }

        /// <summary>
        /// Handles the depth frame data arriving from the sensor
        /// </summary>
        /// <param name="sender">object sending the event</param>
        /// <param name="e">event arguments</param>
        private void Reader_FrameArrived_Depth(object sender, DepthFrameArrivedEventArgs e)
        {
            if (depthFrameCounter == 0)
            {
                depth_master_control = new DepthMasterControl(512, 424,
                512 / 1, 424 / 1, true, null);
            }

            if (depthFrameCounter % 3 == 0)
            {
                //bool depthFrameProcessed = false;

                using (DepthFrame depthFrame = e.FrameReference.AcquireFrame())
                {
                    if (depthFrame != null)
                    {
                        // the fastest way to process the body index data is to directly access 
                        // the underlying buffer
                        using (KinectBuffer depthBuffer = depthFrame.LockImageBuffer())
                        {
                            // verify data and write the color data to the display bitmap
                            if (((this.depthFrameDescription.Width * this.depthFrameDescription.Height) ==
                                (depthBuffer.Size / this.depthFrameDescription.BytesPerPixel)) &&
                                (this.depthFrameDescription.Width == this.depthBitmap.PixelWidth) &&
                                (this.depthFrameDescription.Height == this.depthBitmap.PixelHeight))
                            {
                                // Note: In order to see the full range of depth (including the less reliable far field depth)
                                // we are setting maxDepth to the extreme potential depth threshold
                                ushort maxDepth = ushort.MaxValue;

                                // If you wish to filter by reliable depth distance, uncomment the following line:
                                //// maxDepth = depthFrame.DepthMaxReliableDistance

                                //this.ProcessDepthFrameData(depthBuffer.UnderlyingBuffer, depthBuffer.Size, depthFrame.DepthMinReliableDistance, maxDepth);
                                if (depthFrameCounter % 3 == 0)
                                {
                                    depth_master_control.runDepthAnalysis(depthBuffer.UnderlyingBuffer,
                                        depthFrame.DepthMinReliableDistance, maxDepth, depthFrameCounter,
                                        camera_Depth_Copy, camera_Depth, camera_Depth_Map);

                                    //depth_master_control.getPointCloudBoundaries();

                                }
                                //depthFrameProcessed = true;
                            }
                        }
                    }
                }
            }
            depthFrameCounter++;
        }

        public static ImageSource ToBitmapDepth(int height, int width, byte[] pixels)
        {
            PixelFormat format = PixelFormats.Bgr32;
            int stride = width * format.BitsPerPixel / 8;

            return BitmapSource.Create(width, height, 96, 96, format, null, pixels, stride);
        }

        /// <summary>
        /// Directly accesses the underlying image buffer of the DepthFrame to 
        /// create a displayable bitmap.
        /// This function requires the /unsafe compiler option as we make use of direct
        /// access to the native memory pointed to by the depthFrameData pointer.
        /// </summary>
        /// <param name="depthFrameData">Pointer to the DepthFrame image data</param>
        /// <param name="depthFrameDataSize">Size of the DepthFrame image data</param>
        /// <param name="minDepth">The minimum reliable depth value for the frame</param>
        /// <param name="maxDepth">The maximum reliable depth value for the frame</param>
        private unsafe void ProcessDepthFrameData(IntPtr depthFrameData, uint depthFrameDataSize,
            ushort minDepth, ushort maxDepth)
        {
            // FYI: depthFrameDataSize = 434176

            // depth frame data is a 16 bit value
            ushort* frameData = (ushort*)depthFrameData;
            
            
            // convert depth to a visual representation
            for (int i = 0; i < (int)(depthFrameDataSize / this.depthFrameDescription.BytesPerPixel); ++i)
            {

            }
        }

        /// <summary>
        /// Renders color pixels into the writeableBitmap.
        /// </summary>
        private void RenderDepthPixels()
        {
            this.depthBitmapColor.WritePixels(
                new Int32Rect(0, 0, this.depthBitmap.PixelWidth, this.depthBitmap.PixelHeight),
                 depth_master_control.depthPixelsColor,
                this.depthBitmap.PixelWidth,
                0);
        }

        /// <summary>
        /// Handles the body frame data arriving from the sensor
        /// </summary> 
        /// <param name="sender">object sending the event</param>
        /// <param name="e">event arguments</param>
        private void Reader_FrameArrived(object sender, BodyFrameArrivedEventArgs e)
        {

        }

        private void DrawGestureHead(System.Windows.Point head, DrawingContext drawingContext)
        {
            drawingContext.DrawEllipse(this.headGestureBrush, null, head, headGestureSize, headGestureSize);
        }

        private Body choose_skeleton_gesture(Body[] multiple_bodies)
        {
            Body body_to_run = null;
            int tracking_joint_count = 0;
            bool is_runnable = false, enough_tracked_joints = false, clipped_3_sides = false,
                clipped_bottom = false, past_Z_minimum = false, within_center = false, all_limbs_tracked = false;

            if (body_queue.Count > 0)
            {
                body_to_run = body_queue.Dequeue();

                // Try to see which skeleton is good for gesture:
                while (is_runnable == false)
                {

                    // OPTIONAL: CHECK THAT ALL THE LIMBS THAT ARE USED IN THE GESTURE ANALYSIS ARE TRACKED AND NOT INFERRED:
                    if (body_to_run.Joints[JointType.ShoulderLeft].TrackingState == TrackingState.Tracked &&
                        body_to_run.Joints[JointType.ShoulderRight].TrackingState == TrackingState.Tracked &&
                        body_to_run.Joints[JointType.ElbowLeft].TrackingState == TrackingState.Tracked &&
                        body_to_run.Joints[JointType.ElbowRight].TrackingState == TrackingState.Tracked &&
                        body_to_run.Joints[JointType.HandLeft].TrackingState == TrackingState.Tracked &&
                        body_to_run.Joints[JointType.HandRight].TrackingState == TrackingState.Tracked &&
                        body_to_run.Joints[JointType.SpineShoulder].TrackingState == TrackingState.Tracked &&
                        body_to_run.Joints[JointType.Head].TrackingState == TrackingState.Tracked)
                    {
                        all_limbs_tracked = true;
                    }


                    if (body_to_run.Joints[JointType.ShoulderLeft].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.ShoulderRight].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.ElbowLeft].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.ElbowRight].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.HandLeft].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.HandRight].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.SpineShoulder].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.SpineBase].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.HipLeft].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.HipRight].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.SpineMid].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.AnkleLeft].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.AnkleRight].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;
                    if (body_to_run.Joints[JointType.Head].TrackingState == TrackingState.Tracked)
                        tracking_joint_count++;

                    // Total checked joints are 14; lets check for 12 joints:
                    if (tracking_joint_count >= 7)
                    {
                        enough_tracked_joints = true;

                    }

                    //main_text_block_4.Text = "Enough Tracked Joints: " + enough_tracked_joints.ToString() + "\n";
                    //main_text_block_4.Text += "Tracked Joints: " + tracking_joint_count.ToString() + "\n";
                    // Lets check if the left, right, and top edges are clipped:
                    if (body_to_run.ClippedEdges.HasFlag(FrameEdges.Left) ||
                        body_to_run.ClippedEdges.HasFlag(FrameEdges.Right) ||
                        body_to_run.ClippedEdges.HasFlag(FrameEdges.Top))
                    {
                        clipped_3_sides = true;
                    }

                    //main_text_block_4.Text += "Clipped 3 Sides: " + clipped_3_sides.ToString() + "\n";

                    // Lets check if the bottom edge is clipped:
                    if (body_to_run.ClippedEdges.HasFlag(FrameEdges.Bottom))
                    {
                        clipped_bottom = true;
                    }

                    //main_text_block_4.Text += "Clipped Bottom: " + clipped_bottom.ToString() + "\n";

                    // We also need to delimit the center:
                    // I made a change: we are now measuring the position of the spine shoulder...
                    double X_position = body_to_run.Joints[JointType.SpineShoulder].Position.X;
                    double Z_position = body_to_run.Joints[JointType.SpineShoulder].Position.Z;

                    // Set the closest distance towards camera:
                    if (Z_position > 1.9)    /* OLD: 1.5 meters */
                    {
                        past_Z_minimum = true;
                    }

                    //main_text_block_4.Text += "Z distance: " + Z_position.ToString() + "\n" + "X distance: " + X_position.ToString() + "\n";

                    // Check to see if the skeleton is within the center:
                    if (Math.Abs(X_position) < .4)    /* OLD: 0.2 meters */
                    {
                        within_center = true;
                    }

                    //main_text_block_4.Text += "Within Center: " + within_center.ToString() + "\n";
                    //main_text_block_4.Text += "Past Z Minimum: " + past_Z_minimum.ToString() + "\n";

                    // Looking into all of the boolean variables:
                    if (all_limbs_tracked == true && enough_tracked_joints == true && (clipped_3_sides == false || clipped_bottom == true) &&
                       past_Z_minimum == true && within_center == true)
                    {
                        gesture_master_control.setBody(body_to_run);
                        gesture_master_control.runGestureAnalysis();
                        is_runnable = true;
                        //main_text_block_4.Text += "Running" + "\n";
                    }
                    else
                    {
                        //main_text_block_4.Text += "Not Running" + "\n";
                        tracking_joint_count = 0;
                        enough_tracked_joints = false;
                        clipped_3_sides = false;
                        clipped_bottom = false;
                        past_Z_minimum = false;
                        within_center = false;
                        all_limbs_tracked = false;

                        // Making sure that we do have something to run with:
                        if (body_queue.Count > 0)
                        {
                            body_to_run = body_queue.Dequeue();
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                body_queue.Clear();

            }
            return body_to_run;
        }

        /// <summary>
        /// Draws a body
        /// </summary>
        /// <param name="joints">joints to draw</param>
        /// <param name="jointPoints">translated positions of joints to draw</param>
        /// <param name="drawingContext">drawing context to draw to</param>
        /// <param name="drawingPen">specifies color to draw a specific body</param>
        private void DrawBody(IReadOnlyDictionary<JointType, Joint> joints, IDictionary<JointType, System.Windows.Point> jointPoints, DrawingContext drawingContext, Pen drawingPen)
        {
            // Draw the bones
            foreach (var bone in this.bones)
            {
                this.DrawBone(joints, jointPoints, bone.Item1, bone.Item2, drawingContext, drawingPen);
            }

            // Draw the joints
            foreach (JointType jointType in joints.Keys)
            {
                Brush drawBrush = null;

                TrackingState trackingState = joints[jointType].TrackingState;

                if (trackingState == TrackingState.Tracked)
                {
                    drawBrush = this.trackedJointBrush;
                }
                else if (trackingState == TrackingState.Inferred)
                {
                    drawBrush = this.inferredJointBrush;
                }

                if (drawBrush != null)
                {
                    drawingContext.DrawEllipse(drawBrush, null, jointPoints[jointType], JointThickness, JointThickness);
                }
            }
        }



        /// <summary>
        /// Draws one bone of a body (joint to joint)
        /// </summary>
        /// <param name="joints">joints to draw</param>
        /// <param name="jointPoints">translated positions of joints to draw</param>
        /// <param name="jointType0">first joint of bone to draw</param>
        /// <param name="jointType1">second joint of bone to draw</param>
        /// <param name="drawingContext">drawing context to draw to</param>
        /// /// <param name="drawingPen">specifies color to draw a specific bone</param>
        private void DrawBone(IReadOnlyDictionary<JointType, Joint> joints, IDictionary<JointType, System.Windows.Point> jointPoints, JointType jointType0, JointType jointType1, DrawingContext drawingContext, Pen drawingPen)
        {
            Joint joint0 = joints[jointType0];
            Joint joint1 = joints[jointType1];

            // If we can't find either of these joints, exit
            if (joint0.TrackingState == TrackingState.NotTracked ||
                joint1.TrackingState == TrackingState.NotTracked)
            {
                return;
            }

            // We assume all drawn bones are inferred unless BOTH joints are tracked
            Pen drawPen = this.inferredBonePen;
            if ((joint0.TrackingState == TrackingState.Tracked) && (joint1.TrackingState == TrackingState.Tracked))
            {
                drawPen = drawingPen;
            }

            drawingContext.DrawLine(drawPen, jointPoints[jointType0], jointPoints[jointType1]);
        }

        /// <summary>
        /// Draws a hand symbol if the hand is tracked: red circle = closed, green circle = opened; blue circle = lasso
        /// </summary>
        /// <param name="handState">state of the hand</param>
        /// <param name="handPosition">position of the hand</param>
        /// <param name="drawingContext">drawing context to draw to</param>
        private void DrawHand(HandState handState, System.Windows.Point handPosition, DrawingContext drawingContext)
        {
            switch (handState)
            {
                case HandState.Closed:
                    drawingContext.DrawEllipse(this.handClosedBrush, null, handPosition, HandSize, HandSize);
                    break;

                case HandState.Open:
                    drawingContext.DrawEllipse(this.handOpenBrush, null, handPosition, HandSize, HandSize);
                    break;

                case HandState.Lasso:
                    drawingContext.DrawEllipse(this.handLassoBrush, null, handPosition, HandSize, HandSize);
                    break;
            }
        }

        /// <summary>
        /// Draws indicators to show which edges are clipping body data
        /// </summary>
        /// <param name="body">body to draw clipping information for</param>
        /// <param name="drawingContext">drawing context to draw to</param>
        private void DrawClippedEdges(Body body, DrawingContext drawingContext)
        {
            FrameEdges clippedEdges = body.ClippedEdges;

            if (clippedEdges.HasFlag(FrameEdges.Bottom))
            {
                drawingContext.DrawRectangle(
                    Brushes.Red,
                    null,
                    new Rect(0, this.displayHeight - ClipBoundsThickness, this.displayWidth, ClipBoundsThickness));
            }

            if (clippedEdges.HasFlag(FrameEdges.Top))
            {
                drawingContext.DrawRectangle(
                    Brushes.Red,
                    null,
                    new Rect(0, 0, this.displayWidth, ClipBoundsThickness));
            }

            if (clippedEdges.HasFlag(FrameEdges.Left))
            {
                drawingContext.DrawRectangle(
                    Brushes.Red,
                    null,
                    new Rect(0, 0, ClipBoundsThickness, this.displayHeight));
            }

            if (clippedEdges.HasFlag(FrameEdges.Right))
            {
                drawingContext.DrawRectangle(
                    Brushes.Red,
                    null,
                    new Rect(this.displayWidth - ClipBoundsThickness, 0, ClipBoundsThickness, this.displayHeight));
            }
        }

        /// <summary>
        /// Handles the event which the sensor becomes unavailable (E.g. paused, closed, unplugged).
        /// </summary>
        /// <param name="sender">object sending the event</param>
        /// <param name="e">event arguments</param>
        private void Sensor_IsAvailableChanged(object sender, IsAvailableChangedEventArgs e)
        {
            // on failure, set the status text
            this.StatusText = this.kinectSensor.IsAvailable ? Properties.Resources.RunningStatusText
                                                            : Properties.Resources.SensorNotAvailableStatusText;
        }

        private void TextBox_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {

        }

        private void extractData()
        {
            //string path = "D:/Solar Project/triangle_scope.txt";
            string path = "D:/Solar Project/XBOX ONE/MESA 3D/Extras/teapotTriangles.txt";
            string line;

            System.IO.StreamReader file =
            new System.IO.StreamReader(path);
            while ((line = file.ReadLine()) != null)
            {
                triangles.Add(line);
            }

            file.Close();

            //path = "D:/Solar Project/vertex_scope.txt";
            path = "D:/Solar Project/XBOX ONE/MESA 3D/Extras/teapotVertices.txt";
            System.IO.StreamReader file2 =
            new System.IO.StreamReader(path);
            while ((line = file2.ReadLine()) != null)
            {
                vertices.Add(line);
            }

            file2.Close();
        }

        // Define the lights.
        private void DefineLights()
        {
            AmbientLight ambient_light = new AmbientLight(Colors.Gray);
            DirectionalLight directional_light =
                new DirectionalLight(Colors.Gray, new Vector3D(-1.0, -3.0, -2.0));
            MainModel3Dgroup.Children.Add(ambient_light);
            MainModel3Dgroup.Children.Add(directional_light);
        }
        
        private void DefineModelScope(Model3DGroup model_group)
        {
            MeshGeometry3D scopeMesh = new MeshGeometry3D();
            string[] triangleLineSeperated = new string[3];
            string[] triangleLineVertexSeperated = new string[3];
            char splitter = ' ';

            string vertecesLine = "";
            string[] vertexLineSeperated = new string[3];

            Point3D A = new Point3D();
            Point3D B = new Point3D();
            Point3D C = new Point3D();

            foreach (string triangleLine in triangles)
            {
                triangleLineSeperated = triangleLine.Split(splitter);

                triangleLineVertexSeperated = triangleLineSeperated[0].Split('/');
                vertecesLine = vertices[int.Parse(triangleLineVertexSeperated[0]) - 1];
                vertexLineSeperated = vertecesLine.Split(splitter);
                A = new Point3D(Double.Parse(vertexLineSeperated[0]), Double.Parse(vertexLineSeperated[1]),
                    Double.Parse(vertexLineSeperated[2]));

                triangleLineVertexSeperated = triangleLineSeperated[1].Split('/');
                vertecesLine = vertices[int.Parse(triangleLineVertexSeperated[0]) - 1];
                vertexLineSeperated = vertecesLine.Split(splitter);
                B = new Point3D(Double.Parse(vertexLineSeperated[0]), Double.Parse(vertexLineSeperated[1]),
                    Double.Parse(vertexLineSeperated[2]));

                triangleLineVertexSeperated = triangleLineSeperated[2].Split('/');
                vertecesLine = vertices[int.Parse(triangleLineVertexSeperated[0]) - 1];
                vertexLineSeperated = vertecesLine.Split(splitter);
                C = new Point3D(Double.Parse(vertexLineSeperated[0]), Double.Parse(vertexLineSeperated[1]),
                    Double.Parse(vertexLineSeperated[2]));

                AddTriangle(scopeMesh, A, B, C);
            }

            DiffuseMaterial surface_material = new DiffuseMaterial(Brushes.Orange);
            GeometryModel3D surface_model_scope = new GeometryModel3D(scopeMesh, surface_material);
            surface_model_scope.BackMaterial = surface_material;
            model_group.Children.Add(surface_model_scope);
        }
        
        // Add the model to the Model3DGroup.
        private void DefineModel(Model3DGroup model_group)
        {
            // Make a mesh to hold the surface.
            MeshGeometry3D cuboidMesh = new MeshGeometry3D();
            MeshGeometry3D cuboidFaceMesh = new MeshGeometry3D();
            MeshGeometry3D cuboidArrowMesh = new MeshGeometry3D();

            Point3D A = new Point3D(-3, -6, 0.5);
            Point3D B = new Point3D(3, -6, 0.5);
            Point3D C = new Point3D(-3, -6, -0.5);
            Point3D D = new Point3D(3, -6, -0.5);
            Point3D E = new Point3D(-3, 6, 0.5);
            Point3D F = new Point3D(3, 6, 0.5);
            Point3D G = new Point3D(-3, 6, -0.5);
            Point3D H = new Point3D(3, 6, -0.5);

            Point3D leftPoint = new Point3D(-1.5, 2.5, 0.51);
            Point3D rightPoint = new Point3D(1.5, 2.5, 0.51);
            Point3D centerPoint = new Point3D(0, 5.5, 0.51);

            AddTriangle(cuboidArrowMesh, leftPoint, rightPoint, centerPoint);

            AddTriangle(cuboidFaceMesh, A, E, F);
            AddTriangle(cuboidFaceMesh, A, F, B);

            AddTriangle(cuboidMesh, C, G, H);
            AddTriangle(cuboidMesh, C, H, D);

            AddTriangle(cuboidMesh, A, E, G);
            AddTriangle(cuboidMesh, A, G, C);

            AddTriangle(cuboidMesh, A, B, C);
            AddTriangle(cuboidMesh, B, C, D);

            AddTriangle(cuboidMesh, B, F, H);
            AddTriangle(cuboidMesh, B, H, D);

            AddTriangle(cuboidMesh, F, E, G);
            AddTriangle(cuboidMesh, F, G, H);

            DiffuseMaterial surface_material1 = new DiffuseMaterial(Brushes.Orange);
            DiffuseMaterial surface_material2 = new DiffuseMaterial(Brushes.Violet);
            DiffuseMaterial surface_material3 = new DiffuseMaterial(Brushes.Black);

            GeometryModel3D surface_model_cuboid = new GeometryModel3D(cuboidMesh, surface_material1);
            GeometryModel3D surface_model_face = new GeometryModel3D(cuboidFaceMesh, surface_material2);
            GeometryModel3D surface_model_arrow = new GeometryModel3D(cuboidArrowMesh, surface_material3);

            // Make the surface visible from both sides.
            surface_model_cuboid.BackMaterial = surface_material1;
            surface_model_face.BackMaterial = surface_material2;
            surface_model_arrow.BackMaterial = surface_material3;

            // Add the model to the model groups.
            model_group.Children.Add(surface_model_cuboid);
            model_group.Children.Add(surface_model_face);
            model_group.Children.Add(surface_model_arrow);
        }

        // Add a triangle to the indicated mesh.
        private void AddTriangle(MeshGeometry3D mesh, Point3D point1, Point3D point2, Point3D point3)
        {
            // Get the points' indices.
            int index1 = AddPoint(mesh.Positions, point1);
            int index2 = AddPoint(mesh.Positions, point2);
            int index3 = AddPoint(mesh.Positions, point3);

            // Create the triangle.
            mesh.TriangleIndices.Add(index1);
            mesh.TriangleIndices.Add(index2);
            mesh.TriangleIndices.Add(index3);
        }

        // Create the point and return its new index.
        private int AddPoint(Point3DCollection points, Point3D point)
        {
            // Create the point and return its index.
            points.Add(point);
            return points.Count - 1;
        }

        public Vector3D rotateVectorAboutAxis(Vector3D vector, Vector3D axis, double angle, bool isUsingRadians)
        {
            if(isUsingRadians)
            {
                return Vector3D.Multiply(vector, Math.Cos(angle))
               + Vector3D.Multiply((Vector3D.CrossProduct(axis, vector)), Math.Sin(angle))
               + Vector3D.Multiply(axis, (Vector3D.DotProduct(axis, vector) * (1 - Math.Cos(angle))));
            } else
            {
                return Vector3D.Multiply(vector, Math.Cos(Math.PI * (angle / 180)))
               + Vector3D.Multiply((Vector3D.CrossProduct(axis, vector)), Math.Sin(Math.PI * (angle / 180)))
               + Vector3D.Multiply(axis, (Vector3D.DotProduct(axis, vector) * (1 - Math.Cos(Math.PI * (angle / 180)))));
            }
            
        }

        // Adjust the camera's position.
        private void Window_KeyDown(object sender, KeyEventArgs e)
        {
            double x_offset = 0;
            double y_offset = 0;
            double z_offset = 0;

            switch (e.Key)
            {
                case Key.W:
                    y_offset = 0.5;
                    cameraNeedsPositionUpdate = true;
                    break;
                case Key.S:
                    y_offset = -0.5;
                    cameraNeedsPositionUpdate = true;
                    break;
                case Key.A:
                    x_offset = -0.5;
                    cameraNeedsPositionUpdate = true;
                    break;
                case Key.D:
                    x_offset = 0.5;
                    cameraNeedsPositionUpdate = true;
                    break;
                case Key.Up:
                    CameraPhi += CameraDPhi;
                    cameraVerticalAxis = rotateVectorAboutAxis(cameraVerticalAxis, cameraHorizontalAxis, -1 * CameraDPhi, true);
                    if (CameraPhi > Math.PI / 2.0) CameraPhi = Math.PI / 2.0;
                    cameraNeedsPositionUpdate = true;
                    break;
                case Key.Down:
                    CameraPhi -= CameraDPhi;
                    cameraVerticalAxis = rotateVectorAboutAxis(cameraVerticalAxis, cameraHorizontalAxis, CameraDPhi, true);
                    if (CameraPhi < -Math.PI / 2.0) CameraPhi = -Math.PI / 2.0;
                    cameraNeedsPositionUpdate = true;
                    break;
                case Key.Left:
                    cameraHorizontalAxis = rotateVectorAboutAxis(cameraHorizontalAxis, cameraVerticalAxis, -1 * CameraDPhi, true);
                    CameraTheta += CameraDTheta;
                    cameraNeedsPositionUpdate = true;
                    break;
                case Key.Right:
                    cameraHorizontalAxis = rotateVectorAboutAxis(cameraHorizontalAxis, cameraVerticalAxis, CameraDPhi, true);
                    CameraTheta -= CameraDTheta;
                    cameraNeedsPositionUpdate = true;
                    break;
                case Key.Add:
                case Key.OemPlus:
                    CameraR -= CameraDR * 5;
                    if (CameraR < CameraDR) CameraR = CameraDR;
                    cameraNeedsPositionUpdate = true;
                    break;
                case Key.Subtract:
                case Key.OemMinus:
                    CameraR += CameraDR * 5;
                    cameraNeedsPositionUpdate = true;
                    break;
            }
            
            if (cameraNeedsPositionUpdate == true)
            {
                PositionCamera(x_offset, y_offset, z_offset);
                cameraNeedsPositionUpdate = false;
            }
        }

        // Position the camera.
        private void PositionCamera(double x_offset, double y_offset, double z_offset)
        {

            // Calculate the camera's position in Cartesian coordinates.
            double y = CameraR * Math.Sin(CameraPhi);
            double hyp = CameraR * Math.Cos(CameraPhi);
            double x = hyp * Math.Cos(CameraTheta);
            double z = hyp * Math.Sin(CameraTheta);
            TheCamera.Position = new Point3D(x + x_offset, y + y_offset, z + z_offset);

            // Look toward the origin.
            TheCamera.LookDirection = new Vector3D(-x - x_offset, -y - y_offset, -z - z_offset);

            // Set the Up direction.
            TheCamera.UpDirection = new Vector3D(0, 1, 0);

            // Console.WriteLine("Camera.Position: (" + x + ", " + y + ", " + z + ")");
        }

        // Position the camera.
        private void PositionCameraStatic()
        {
            // Calculate the camera's position in Cartesian coordinates.
            double y = -60;
            double x = 0;
            double z = 60;
            TheCamera.Position = new Point3D(x, y, z);

            // Look toward the origin.
            TheCamera.LookDirection = new Vector3D(-x, -y, -z);

            // Set the Up direction.
            TheCamera.UpDirection = new Vector3D(0, 1, 0);

            // Console.WriteLine("Camera.Position: (" + x + ", " + y + ", " + z + ")");
        }

        private void RenderPointCloudButton_Click(object sender, RoutedEventArgs e)
        {
            createPointCloud3DView();
        }

        private void createPointCloud3DView()
        {
            MeshGeometry3D cuboidMesh = new MeshGeometry3D();
            DiffuseMaterial surface_material = new DiffuseMaterial(Brushes.Violet);
            
            var keys = verticesGrid.Keys;
            Dictionary<int, Point3D> containedGridVertices = new Dictionary<int, Point3D>();

            foreach (string key in keys)
            {
                containedGridVertices = verticesGrid[key];
                var containedGridVerticesKeys = containedGridVertices.Keys;
                
                foreach (int vertex in containedGridVerticesKeys)
                {
                    Point3D point = containedGridVertices[vertex];
                    drawSinglePoint(cuboidMesh, point);
                }
            }

            GeometryModel3D surface_model_cuboid = new GeometryModel3D(cuboidMesh, surface_material);

            // Make the surface visible from both sides.
            surface_model_cuboid.BackMaterial = surface_material;

            // Add the model to the model groups.
            MainModel3Dgroup.Children.Add(surface_model_cuboid);
        }

        private void drawSinglePoint(MeshGeometry3D mesh, Point3D vertex)
        {

            double X = vertex.X / 100.0;
            double Y = vertex.Y / 100.0;
            double Z = vertex.Z / 100.0;
            double sideLengthHalf = 0.003;
           

            Point3D A = new Point3D(X + -1 * sideLengthHalf, Y + -1 * sideLengthHalf, Z + sideLengthHalf);
            Point3D B = new Point3D(X + sideLengthHalf, Y + -1 * sideLengthHalf, Z + sideLengthHalf);
            Point3D C = new Point3D(X + -1 * sideLengthHalf, Y + -1 * sideLengthHalf, Z + -1 * sideLengthHalf);
            Point3D D = new Point3D(X + sideLengthHalf, Y + -1 * sideLengthHalf, Z + -1 * sideLengthHalf);
            Point3D E = new Point3D(X + -1 * sideLengthHalf, Y + sideLengthHalf, Z + sideLengthHalf);
            Point3D F = new Point3D(X + sideLengthHalf, Y + sideLengthHalf, Z + sideLengthHalf);
            Point3D G = new Point3D(X + -1 * sideLengthHalf, Y + sideLengthHalf, Z + -1 * sideLengthHalf);
            Point3D H = new Point3D(X + sideLengthHalf, Y + sideLengthHalf, Z + -1 * sideLengthHalf);
            
            AddTriangle(mesh, A, E, F);
            AddTriangle(mesh, A, F, B);

            AddTriangle(mesh, C, G, H);
            AddTriangle(mesh, C, H, D);

            AddTriangle(mesh, A, E, G);
            AddTriangle(mesh, A, G, C);

            AddTriangle(mesh, A, B, C);
            AddTriangle(mesh, B, C, D);

            AddTriangle(mesh, B, F, H);
            AddTriangle(mesh, B, H, D);

            AddTriangle(mesh, F, E, G);
            AddTriangle(mesh, F, G, H);
            
        }

        private void RenderExampleTrianglesButton_Click(object sender, RoutedEventArgs e)
        {
            simplifyGrid();
            renderTriangles(planeVerticesGrid);
        }

        private void RenderTrianglesButton_Click(object sender, RoutedEventArgs e)
        {
            renderTriangles(verticesGrid);

        }

        private void renderTriangles(Dictionary<string, Dictionary<int, Point3D>> verticesGrid)
        {
            Dictionary<int, Point3D> containedGridVertices = new Dictionary<int, Point3D>();
            var keys = verticesGrid.Keys;
            Point3D vertexPoint;
            Point3D[] threeVertexPoint = new Point3D[3];
            int i = 0;
            Vector3D firstVector, secondVector, normalVector;

            MeshGeometry3D pointCloudMesh = new MeshGeometry3D();
            DiffuseMaterial surface_material = new DiffuseMaterial(Brushes.Violet);

            foreach (string key in keys)
            {
                containedGridVertices = verticesGrid[key];
                var containedGridVerticesKeys = containedGridVertices.Keys;

                if (containedGridVerticesKeys.Count >= 3)
                {
                    if (containedGridVerticesKeys.Count == 3)
                    {
                        foreach (int vertex in containedGridVerticesKeys)
                        {
                            if(i < 3)
                            {
                                threeVertexPoint[i] = containedGridVertices[vertex];
                            }
                            i++;
                        }
                        i = 0;

                        firstVector = threeVertexPoint[1] - threeVertexPoint[0];
                        secondVector = threeVertexPoint[2] - threeVertexPoint[0];

                        normalVector = new Vector3D();
                        normalVector = Vector3D.CrossProduct(firstVector, secondVector);

                        Point3D point1 = new Point3D(threeVertexPoint[0].X / 1, threeVertexPoint[0].Y / 1, threeVertexPoint[0].Z / 1);
                        Point3D point2 = new Point3D(threeVertexPoint[1].X / 1, threeVertexPoint[1].Y / 1, threeVertexPoint[1].Z / 1);
                        Point3D point3 = new Point3D(threeVertexPoint[2].X / 1, threeVertexPoint[2].Y / 1, threeVertexPoint[2].Z / 1);

                        AddTriangle(pointCloudMesh, point1, point2, point3);
                    }
                    else
                    {
                        foreach (int vertex in containedGridVerticesKeys)
                        {
                            vertexPoint = containedGridVertices[vertex];
                        }
                    }
                } else
                {
                    foreach (int vertex in containedGridVerticesKeys)
                    {
                        Point3D point1 = new Point3D(containedGridVertices[vertex].X / 1 + 2, containedGridVertices[vertex].Y / 1,
                            containedGridVertices[vertex].Z / 1);
                        drawSinglePoint(pointCloudMesh, point1);
                    }
                }
            }

            GeometryModel3D surface_model_cuboid = new GeometryModel3D(pointCloudMesh, surface_material);

            // Make the surface visible from both sides.
            surface_model_cuboid.BackMaterial = surface_material;

            // Add the model to the model groups.
            MainModel3Dgroup.Children.Add(surface_model_cuboid);
        }


        private void RenderExampleModelButton_Click(object sender, RoutedEventArgs e)
        {
            DefineModelScope(MainModel3Dgroup);
        }

        private void TabControl_PreviewKeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Left || e.Key == Key.Right)
                e.Handled = true;
        }


        private int findClosestTriangleVertex(Point3D[] pointArr, Point3D point)
        {
            double distance1, distance2, distance3;
            double X, Y, Z;

            X = point.X - pointArr[0].X;
            Y = point.Y - pointArr[0].Y;
            Z = point.Z - pointArr[0].Z;

            distance1 = Math.Sqrt(X * X + Y * Y + Z * Z);

            X = point.X - pointArr[1].X;
            Y = point.Y - pointArr[1].Y;
            Z = point.Z - pointArr[1].Z;

            distance2 = Math.Sqrt(X * X + Y * Y + Z * Z);

            X = point.X - pointArr[2].X;
            Y = point.Y - pointArr[2].Y;
            Z = point.Z - pointArr[2].Z;

            distance3 = Math.Sqrt(X * X + Y * Y + Z * Z);

            if(distance1 < distance2 && distance1 < distance3)
            {
                return 0;
            } else
            {
                if(distance2 < distance3)
                {
                    return 1;
                } else
                {
                    return 2;
                }
            }
        }

        private Point3D mergeTwoPoints(Point3D point1, Point3D point2)
        {
            Point3D mergedPoint = new Point3D();
            double X, Y, Z;

            X = (point1.X - point2.X) / 2;
            Y = (point1.Y - point2.Y) / 2;
            Z = (point1.Z - point2.Z) / 2;

            mergedPoint = new Point3D(point2.X + X, point2.Y + Y, point2.Z + Z);

            return mergedPoint;
        }

        private void createPlaneTriangles( List<Point3D> intersections, int numberOfIntersections)
        {
            Point3D[] trianglePoints; 
            if(numberOfIntersections == 3)
            {
                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[1];
                trianglePoints[2] = intersections[2];

                planeTrianglesList.Add(trianglePoints);
            }
            else if(numberOfIntersections == 4)
            {
                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[1];
                trianglePoints[2] = intersections[2];

                planeTrianglesList.Add(trianglePoints);

                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[2];
                trianglePoints[2] = intersections[3];

                planeTrianglesList.Add(trianglePoints);
            }
            else if (numberOfIntersections == 5)
            {
                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[1];
                trianglePoints[2] = intersections[2];

                planeTrianglesList.Add(trianglePoints);

                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[2];
                trianglePoints[2] = intersections[3];

                planeTrianglesList.Add(trianglePoints);

                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[3];
                trianglePoints[2] = intersections[4];
                
                planeTrianglesList.Add(trianglePoints);
            }
            else if (numberOfIntersections == 6)
            {
                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[1];
                trianglePoints[2] = intersections[2];

                planeTrianglesList.Add(trianglePoints);

                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[2];
                trianglePoints[2] = intersections[3];

                planeTrianglesList.Add(trianglePoints);

                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[3];
                trianglePoints[2] = intersections[4];

                planeTrianglesList.Add(trianglePoints);

                trianglePoints = new Point3D[3];
                trianglePoints[0] = intersections[0];
                trianglePoints[1] = intersections[4];
                trianglePoints[2] = intersections[5];

                planeTrianglesList.Add(trianglePoints);
            }
        }

        private void simplifyGrid()
        {
            Dictionary<int, Point3D> containedGridVertices = new Dictionary<int, Point3D>();
            Dictionary<int, Point3D> containedGridVerticesPlane;
            var keys = verticesGrid.Keys;
            int i = 0;
            Point3D[] trianglePoints = new Point3D[3];
            int planeVerticesIndex = 0;
            Vector3D vector1, vector2, normalVector;
            double xCoeff, yCoeff, zCoeff, contstantOfPlaneEq;
            double[] cubeLimits = new double[6];
            int numberOfIntersections = 0;
            string[] pairSeperatedKey;
            string[] rangeSeperatedKey;

            foreach (string key in keys)
            {
                pairSeperatedKey = key.Split(',');
                rangeSeperatedKey = pairSeperatedKey[0].Split('/');
                cubeLimits[0] = Double.Parse(rangeSeperatedKey[0]);
                cubeLimits[1] = Double.Parse(rangeSeperatedKey[1]);

                rangeSeperatedKey = pairSeperatedKey[1].Split('/');
                cubeLimits[2] = Double.Parse(rangeSeperatedKey[0]);
                cubeLimits[3] = Double.Parse(rangeSeperatedKey[1]);

                rangeSeperatedKey = pairSeperatedKey[2].Split('/');
                cubeLimits[4] = Double.Parse(rangeSeperatedKey[0]);
                cubeLimits[5] = Double.Parse(rangeSeperatedKey[1]);


                containedGridVertices = verticesGrid[key];
                var containedGridVerticesKeys = containedGridVertices.Keys;
                
                containedGridVerticesPlane = new Dictionary<int, Point3D>();
                
                trianglePoints = new Point3D[3];
                i = 0;
                int closestIndex = 0;

                foreach (int vertex in containedGridVerticesKeys)
                {
                    Point3D point = containedGridVertices[vertex];

                    if(i > 2)
                    {
                        closestIndex = findClosestTriangleVertex(trianglePoints, point);
                        trianglePoints[closestIndex] = mergeTwoPoints(trianglePoints[closestIndex], point);
                    } else
                    {
                        trianglePoints[i] = point;
                        i++;
                    }
                    
                }
                
                /*
                if(i > 2)
                {
                    // Find normal Vector of Triangle:
                    vector1 = new Vector3D(trianglePoints[1].X - trianglePoints[0].X, trianglePoints[1].X - trianglePoints[0].X,
                        trianglePoints[1].X - trianglePoints[0].X);

                    vector2 = new Vector3D(trianglePoints[2].X - trianglePoints[0].X, trianglePoints[2].X - trianglePoints[0].X,
                        trianglePoints[2].X - trianglePoints[0].X);

                    normalVector = Vector3D.CrossProduct(vector1, vector2);

                    // Lets get equation of plane:
                    contstantOfPlaneEq = trianglePoints[0].X * normalVector.X + trianglePoints[0].Y * normalVector.Y
                        + trianglePoints[0].Z * normalVector.Z;
                    
                    // Lets get the intersections of this plane with the grid:
                    List<Point3D> intersections = findCubeCrossSections(cubeLimits, normalVector.X, normalVector.Y,
                        normalVector.Z, contstantOfPlaneEq);
                    

                    createPlaneTriangles(intersections, intersections.Count);
                }
                */

                for (int j = 0; j < i; j++)
                {
                    containedGridVerticesPlane.Add(planeVerticesIndex++, trianglePoints[j]);
                }

                planeVerticesGrid.Add(key, containedGridVerticesPlane);
            }
        }

        private void GetPointCloudFromExample_Click(object sender, RoutedEventArgs e)
        {
            //depth_master_control.pointCloudArray

            string path = "D:/Solar Project/XBOX ONE/MESA 3D/3DSandbox/3DSandbox/Text Files/saved_point_cloud.txt";
            string strToWrite = "";
            int limit = vertices.Count;
            int k = 0;
            Byte[] info;
            double X = 0.0;
            double Y = 0.0;
            double Z = 0.0;
            double X_gridLimitFloor = 0.0;
            double X_gridLimitCeiling = 0.0;
            double Y_gridLimitFloor = 0.0;
            double Y_gridLimitCeiling = 0.0;
            double Z_gridLimitFloor = 0.0;
            double Z_gridLimitCeiling = 0.0;
            string[] gridLimitsStr = new string[6];
            string gridLimitsStrWholes = "";
            string[] vertexStrArr;

            int i = 0;

            double cellSize = 5.0;
            Dictionary<int, Point3D> containedGridVertices = new Dictionary<int, Point3D>();
            
            foreach(string vertexStr in vertices)
            {
                vertexStrArr = vertexStr.Split(' ');

                X = Double.Parse(vertexStrArr[0]) / cellSize;
                Y = Double.Parse(vertexStrArr[1]) / cellSize;
                Z = Double.Parse(vertexStrArr[2]) / cellSize;

                gridLimitsStr = new string[6];
                gridLimitsStr[0] = Math.Floor(X).ToString();
                gridLimitsStr[2] = Math.Floor(Y).ToString();
                gridLimitsStr[4] = Math.Floor(Z).ToString();
                gridLimitsStr[1] = Math.Ceiling(X).ToString();
                gridLimitsStr[3] = Math.Ceiling(Y).ToString();
                gridLimitsStr[5] = Math.Ceiling(Z).ToString();

                gridLimitsStrWholes = gridLimitsStr[0] + "/" + gridLimitsStr[1] + "," + gridLimitsStr[2]
                        + "/" + gridLimitsStr[3] + "," + gridLimitsStr[4] + "/" + gridLimitsStr[5];

                if (verticesGrid.ContainsKey(gridLimitsStrWholes))
                {
                    containedGridVertices = verticesGrid[gridLimitsStrWholes];
                    containedGridVertices.Add(i, new Point3D(X * cellSize, Y * cellSize, Z * cellSize));
                }
                else
                {
                    containedGridVertices = new Dictionary<int, Point3D>();
                    containedGridVertices.Add(i, new Point3D(X * cellSize, Y * cellSize, Z * cellSize));
                    verticesGrid.Add(gridLimitsStrWholes, containedGridVertices);
                }
                i++;
            }

            int maxVerticesPerCube = 0;

            path = "D:/Solar Project/XBOX ONE/MESA 3D/3DSandbox/3DSandbox/Text Files/saved_point_cloud2.txt";
            using (FileStream fs = File.Open(path, FileMode.Open, FileAccess.Write, FileShare.None))
            {
                var keys = verticesGrid.Keys;

                foreach (string key in keys)
                {
                    containedGridVertices = verticesGrid[key];
                    var containedGridVerticesKeys = containedGridVertices.Keys;

                    int j = containedGridVerticesKeys.Count;

                    foreach (int vertex in containedGridVerticesKeys)
                    {
                        Point3D point = containedGridVertices[vertex];
                        strToWrite = "[" + key + "]";
                        strToWrite += "  :  v = " + vertex + " pos:";
                        strToWrite += point.ToString() + "\n";
                        info = new UTF8Encoding(true).GetBytes(strToWrite);
                        fs.Write(info, 0, info.Length);
                    }

                    if (j > maxVerticesPerCube)
                    {
                        maxVerticesPerCube = j;
                    }
                }

                info = new UTF8Encoding(true).GetBytes("Max: " + maxVerticesPerCube + "\n");
                fs.Write(info, 0, info.Length);

                int count = 0;
                i = 0;
                keys = verticesGrid.Keys;

                for (i = 0; i < maxVerticesPerCube; i++)
                {
                    count = 0;
                    foreach (string key in keys)
                    {
                        containedGridVertices = verticesGrid[key];
                        var containedGridVerticesKeys = containedGridVertices.Keys;
                        if ((i + 1) == containedGridVerticesKeys.Count)
                        {
                            count++;
                        }
                    }

                    info = new UTF8Encoding(true).GetBytes("Number of Verticees: " + (i + 1) + " : " + count + "\n");
                    fs.Write(info, 0, info.Length);
                }

                int numOfLoneVerticees = verticesGrid.Keys.Count;
                int numOfLoneCubes = verticesGrid.Keys.Count;

                string[] neighborStr;

                
                foreach (string key in keys)
                {
                    containedGridVertices = verticesGrid[key];
                    var containedGridVerticesKeys = containedGridVertices.Keys;
                    if (containedGridVerticesKeys.Count == 1)
                    {
                        neighborStr = findAllNeighborKeys(key, 3);
                        foreach(string singleNeighbor in neighborStr)
                        {
                            if(verticesGrid.ContainsKey(singleNeighbor))
                            {
                                numOfLoneVerticees--;
                                break;
                            }
                        }
                    }
                    
                    if (containedGridVerticesKeys.Count > 0)
                    {
                        neighborStr = findAllNeighborKeys(key, 7);
                        foreach (string singleNeighbor in neighborStr)
                        {
                            if (verticesGrid.ContainsKey(singleNeighbor))
                            {
                                numOfLoneCubes--;
                                break;
                            }
                        }
                    }
                }
                

                info = new UTF8Encoding(true).GetBytes("Number of Lone Vertices" + " : " + numOfLoneVerticees + "\n");
                fs.Write(info, 0, info.Length);
                info = new UTF8Encoding(true).GetBytes("Number of Lone Cubes" + " : " + numOfLoneCubes + "\n");
                fs.Write(info, 0, info.Length);

            }
        }


        private void SavePointCloudButton_Click(object sender, RoutedEventArgs e)
        {
            //depth_master_control.pointCloudArray
            
            string path = "D:/Solar Project/XBOX ONE/MESA 3D/3DSandbox/3DSandbox/Text Files/saved_point_cloud.txt";
            string strToWrite = "";
            int limit = depth_master_control.pointCloudArrayDouble.Length;
            int k = 0;
            Byte[] info;
            double X = 0.0;
            double Y = 0.0;
            double Z = 0.0;
            double X_gridLimitFloor = 0.0;
            double X_gridLimitCeiling = 0.0;
            double Y_gridLimitFloor = 0.0;
            double Y_gridLimitCeiling = 0.0;
            double Z_gridLimitFloor = 0.0;
            double Z_gridLimitCeiling = 0.0;
            string[] gridLimitsStr = new string[6];
            string gridLimitsStrWholes = "";

            Dictionary<int, Point3D> containedGridVertices = new Dictionary<int, Point3D>();

            using (FileStream fs = File.Open(path, FileMode.Open, FileAccess.Write, FileShare.None))
            {
                for (int i = 0; i < limit; i = i + 3)
                {
                    if(depth_master_control.pointCloudArray[i] != 0 && depth_master_control.pointCloudArray[i + 1] != 0
                        && depth_master_control.pointCloudArray[i + 2] != 0)
                    {

                        X = depth_master_control.pointCloudArrayDouble[i + k++] / 8;
                        Y = depth_master_control.pointCloudArrayDouble[i + k++] / 8;
                        Z = depth_master_control.pointCloudArrayDouble[i + k++] / 8;
                        k = 0;

                        X_gridLimitFloor = Math.Floor(X);
                        Y_gridLimitFloor = Math.Floor(Y);
                        Z_gridLimitFloor = Math.Floor(Z);
                        X_gridLimitCeiling = Math.Ceiling(X);
                        Y_gridLimitCeiling = Math.Ceiling(Y);
                        Z_gridLimitCeiling = Math.Ceiling(Z);

                        gridLimitsStr = new string[6];
                        gridLimitsStr[0] = Math.Floor(X).ToString();
                        gridLimitsStr[2] = Math.Floor(Y).ToString();
                        gridLimitsStr[4] = Math.Floor(Z).ToString();
                        gridLimitsStr[1] = Math.Ceiling(X).ToString();
                        gridLimitsStr[3] = Math.Ceiling(Y).ToString();
                        gridLimitsStr[5] = Math.Ceiling(Z).ToString();

                        gridLimitsStrWholes = gridLimitsStr[0] + "/" + gridLimitsStr[1] + "," + gridLimitsStr[2]
                            + "/" + gridLimitsStr[3] + "," + gridLimitsStr[4] + "/" + gridLimitsStr[5];

                        if (verticesGrid.ContainsKey(gridLimitsStrWholes))
                        {
                            containedGridVertices = verticesGrid[gridLimitsStrWholes];
                            containedGridVertices.Add(i, new Point3D(X * 8, Y * 8, Z * 8));
                        }
                        else
                        {
                            containedGridVertices = new Dictionary<int, Point3D>();
                            containedGridVertices.Add(i, new Point3D(X * 8, Y * 8, Z * 8));
                            verticesGrid.Add(gridLimitsStrWholes, containedGridVertices);
                        }

                        strToWrite = (depth_master_control.pointCloudArrayDouble[i + k++]) + " " +
                                     (depth_master_control.pointCloudArrayDouble[i + k++]) + " " +
                                     (depth_master_control.pointCloudArrayDouble[i + k++]) + "\n";
                        k = 0;
                        info = new UTF8Encoding(true).GetBytes(strToWrite);
                        fs.Write(info, 0, info.Length);
                    }
                }
            }
            
            int maxVerticesPerCube = 0;

            path = "D:/Solar Project/XBOX ONE/MESA 3D/3DSandbox/3DSandbox/Text Files/saved_point_cloud2.txt";
            using (FileStream fs = File.Open(path, FileMode.Open, FileAccess.Write, FileShare.None))
            {
                var keys = verticesGrid.Keys;

                foreach(string key in keys)
                {
                    containedGridVertices = verticesGrid[key];
                    var containedGridVerticesKeys = containedGridVertices.Keys;

                    int j = containedGridVerticesKeys.Count;
                    
                    foreach (int vertex in containedGridVerticesKeys)
                    {
                        Point3D point = containedGridVertices[vertex];
                        strToWrite = "[" + key + "]";
                        strToWrite += "  :  v = " + vertex + " pos:";
                        strToWrite += point.ToString() + "\n";
                        info = new UTF8Encoding(true).GetBytes(strToWrite);
                        fs.Write(info, 0, info.Length);
                    }

                    if (j > maxVerticesPerCube)
                    {
                        maxVerticesPerCube = j;
                    }
                }

                info = new UTF8Encoding(true).GetBytes("Max: " + maxVerticesPerCube + "\n");
                fs.Write(info, 0, info.Length);

                int count = 0;
                int i = 0;
                keys = verticesGrid.Keys;

                for(i = 0; i < maxVerticesPerCube; i++)
                {
                    count = 0;
                    foreach (string key in keys)
                    {
                        containedGridVertices = verticesGrid[key];
                        var containedGridVerticesKeys = containedGridVertices.Keys;
                        if ((i + 1) == containedGridVerticesKeys.Count)
                        {
                            count++;
                        }
                    }

                    info = new UTF8Encoding(true).GetBytes("Number of Verticees: " + (i + 1) + " : " + count + "\n");
                    fs.Write(info, 0, info.Length);
                }

                int numOfLoneVerticees = verticesGrid.Keys.Count;
                int numOfLoneCubes = verticesGrid.Keys.Count;

                string[] neighborStr;

                /*
                foreach (string key in keys)
                {
                    containedGridVertices = verticesGrid[key];
                    var containedGridVerticesKeys = containedGridVertices.Keys;
                    if (containedGridVerticesKeys.Count == 1)
                    {
                        neighborStr = findAllNeighborKeys(key, 3);
                        foreach(string singleNeighbor in neighborStr)
                        {
                            if(verticesGrid.ContainsKey(singleNeighbor))
                            {
                                numOfLoneVerticees--;
                                break;
                            }
                        }
                    }
                    
                    if (containedGridVerticesKeys.Count > 0)
                    {
                        neighborStr = findAllNeighborKeys(key, 7);
                        foreach (string singleNeighbor in neighborStr)
                        {
                            if (verticesGrid.ContainsKey(singleNeighbor))
                            {
                                numOfLoneCubes--;
                                break;
                            }
                        }
                    }
                }
                */

                info = new UTF8Encoding(true).GetBytes("Number of Lone Vertices" + " : " + numOfLoneVerticees + "\n");
                fs.Write(info, 0, info.Length);
                info = new UTF8Encoding(true).GetBytes("Number of Lone Cubes" + " : " + numOfLoneCubes + "\n");
                fs.Write(info, 0, info.Length);

            }
        }
        
        private List<Point3D> findCubeCrossSections(double[] cubeLimits, double xCoeff, double yCoeff,
                                            double zCoeff, double constant)
        {
            int numberOfIntersections = 0;
            List<Point3D> intersections = new List<Point3D>();
            double x, y, z;

            // Side AB: z axis
            x = cubeLimits[0];
            y = cubeLimits[3];
            z = (constant - (x * xCoeff) - (y * yCoeff)) / zCoeff;
            if(z >= cubeLimits[4] && z <= cubeLimits[5])
            {
                intersections.Add(new Point3D(x, y, z));
            }
            // Side BC: x axis
            z = cubeLimits[4];
            y = cubeLimits[3];
            x = (constant - (z * zCoeff) - (y * yCoeff)) / xCoeff;
            if (x >= cubeLimits[0] && z <= cubeLimits[1])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side CD: z axis
            x = cubeLimits[1];
            y = cubeLimits[3];
            z = (constant - (x * xCoeff) - (y * yCoeff)) / zCoeff;
            if (z >= cubeLimits[4] && z <= cubeLimits[5])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side DA: x axis
            z = cubeLimits[5];
            y = cubeLimits[3];
            x = (constant - (z * zCoeff) - (y * yCoeff)) / xCoeff;
            if (x >= cubeLimits[0] && z <= cubeLimits[1])
            {
                intersections.Add(new Point3D(x, y, z));

            }


            // Side EF: z axis
            x = cubeLimits[0];
            y = cubeLimits[2];
            z = (constant - (x * xCoeff) - (y * yCoeff)) / zCoeff;
            if (z >= cubeLimits[4] && z <= cubeLimits[5])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side FG: x axis
            z = cubeLimits[4];
            y = cubeLimits[2];
            x = (constant - (z * zCoeff) - (y * yCoeff)) / xCoeff;
            if (x >= cubeLimits[0] && z <= cubeLimits[1])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side GH: z axis
            x = cubeLimits[1];
            y = cubeLimits[2];
            z = (constant - (x * xCoeff) - (y * yCoeff)) / zCoeff;
            if (z >= cubeLimits[4] && z <= cubeLimits[5])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side HE: x axis
            z = cubeLimits[5];
            y = cubeLimits[2];
            x = (constant - (z * zCoeff) - (y * yCoeff)) / xCoeff;
            if (x >= cubeLimits[0] && z <= cubeLimits[1])
            {
                intersections.Add(new Point3D(x, y, z));

            }


            // Side AE: y axis
            x = cubeLimits[0];
            z = cubeLimits[5];
            y = (constant - (z * zCoeff) - (x * xCoeff)) / yCoeff;
            if (y >= cubeLimits[2] && z <= cubeLimits[3])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side BF: y axis
            x = cubeLimits[0];
            z = cubeLimits[4];
            y = (constant - (z * zCoeff) - (x * xCoeff)) / yCoeff;
            if (y >= cubeLimits[2] && z <= cubeLimits[3])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side CG: y axis
            x = cubeLimits[1];
            z = cubeLimits[4];
            y = (constant - (z * zCoeff) - (x * xCoeff)) / yCoeff;
            if (y >= cubeLimits[2] && z <= cubeLimits[3])
            {
                intersections.Add(new Point3D(x, y, z));

            }
            // Side DH: y axis
            x = cubeLimits[1];
            z = cubeLimits[5];
            y = (constant - (z * zCoeff) - (x * xCoeff)) / yCoeff;
            if (y >= cubeLimits[2] && z <= cubeLimits[3])
            {
                intersections.Add(new Point3D(x, y, z));

            }

            return intersections;
        }

        private string[] findAllNeighborKeys(string key, int neighborhoodSize)
        {
            double X_gridLimitFloor = 0;
            double X_gridLimitCeiling = 0;
            double Y_gridLimitFloor = 0;
            double Y_gridLimitCeiling = 0;
            double Z_gridLimitFloor = 0;
            double Z_gridLimitCeiling = 0;

            double X_gridLimitFloorCurr = 0;
            double X_gridLimitCeilingCurr = 0;
            double Y_gridLimitFloorCurr = 0;
            double Y_gridLimitCeilingCurr = 0;
            double Z_gridLimitFloorCurr = 0;
            double Z_gridLimitCeilingCurr = 0;

            string[] allNeighborKeys = new string[neighborhoodSize * neighborhoodSize * neighborhoodSize - 1];

            string[] pairSeperatedKey;
            string[] rangeSeperatedKey;

            int i, j, k, strIndex = 0;
            int midpoint = neighborhoodSize / 2;

            int offsetStarting = (neighborhoodSize/2) * -1;
            int[] offsets = new int[neighborhoodSize];
            for (i = 0; i < neighborhoodSize; i++)
            {
                offsets[i] = offsetStarting;
                offsetStarting++;
            }
            
            pairSeperatedKey = key.Split(',');
            rangeSeperatedKey = pairSeperatedKey[0].Split('/');
            X_gridLimitFloorCurr = Double.Parse(rangeSeperatedKey[0]);
            X_gridLimitCeilingCurr = Double.Parse(rangeSeperatedKey[1]);

            rangeSeperatedKey = pairSeperatedKey[1].Split('/');
            Y_gridLimitFloorCurr = Double.Parse(rangeSeperatedKey[0]);
            Y_gridLimitCeilingCurr = Double.Parse(rangeSeperatedKey[1]);

            rangeSeperatedKey = pairSeperatedKey[2].Split('/');
            Z_gridLimitFloorCurr = Double.Parse(rangeSeperatedKey[0]);
            Z_gridLimitCeilingCurr = Double.Parse(rangeSeperatedKey[1]);

            for(i = 0; i < neighborhoodSize; i++)
            {
                for (j = 0; j < neighborhoodSize; j++)
                {
                    for (k = 0; k < neighborhoodSize; k++)
                    {
                        if(!(i == midpoint && j == midpoint && k == midpoint))
                        {
                            X_gridLimitFloor = X_gridLimitFloorCurr + offsets[i];
                            X_gridLimitCeiling = X_gridLimitCeilingCurr + offsets[i];

                            Y_gridLimitFloor = Y_gridLimitFloorCurr + offsets[j];
                            Y_gridLimitCeiling = Y_gridLimitCeilingCurr + offsets[j];

                            Z_gridLimitFloor = Z_gridLimitFloorCurr + offsets[k];
                            Z_gridLimitCeiling = Z_gridLimitCeilingCurr + offsets[k];

                            allNeighborKeys[strIndex] = X_gridLimitFloor + "/" + X_gridLimitCeiling + "," +
                                Y_gridLimitFloor + "/" + Y_gridLimitCeiling + "," +
                                Z_gridLimitFloor + "/" + Z_gridLimitCeiling;
                            strIndex++;
                        }
                    }
                }
            }
            
            return allNeighborKeys;
        }
        
    }
}

